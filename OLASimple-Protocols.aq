{"config":{"title":"OLA Simple Workflow","description":"Aquarium workflow enabling rapid HIV drug resistance detection using the OLA simple technique.","copyright":"","version":"0.2.02","authors":null,"maintainer":{"name":"Abe Miller","email":"abraham.r.m@gmail.com"},"acknowledgements":null,"github":{"user":"gamemackerel","repo":"OLASimple-Protocols","organization":"OLA-Simple"},"keywords":null,"aquadoc_version":"1.0.2","aquarium_version":"\u003c%= Bioturk::Application.config.aquarium_version %\u003e"},"components":[{"sample_types":[],"object_types":[],"operation_type":{"name":"Pipette Training","category":"Misc.","deployed":false,"on_the_fly":false,"field_types":[],"protocol":"class Protocol\n\ndef main\n    \n    show do\n      title \"Gather Materials\"\n      check \"Four 14 mL test tubes\"\n      check \"Four different colors of food coloring\"\n      check \"Five 1.5 mL tubes\"\n    end\n\n    show do\n      title \"Exercise Preparation\"\n      note \"Fill each test tube about 2/3 full with sink water.\"\n      note \"To each test tube add one drop of a different color of food coloring.\"\n      warning \"Make sure the blue and purple drops are very small because the color is dark.\"\n      note \"Label tubes as I, II, III, and IV.\"\n      note \"Put test tubes in a test tube rack and set aside.\"\n    end\n    \n    show do\n      title \"Large Volume Exercise\"\n      note \"Take out five 1.5 mL tubes and label them A - E. Put tubes C - D off to the side.\"\n      note \"Using the 1 mL pipette, add solution I to the tubes: 100 uL to A and 150 uL to B.\"\n      note \"Using the same pipette but a fresh tip, add solution II to the tubes: 200 uL to A and 250 uL to B.\"\n      note \"Using the same pipette but a fresh tip, add solution III to the tubes: 150 uL to A and 350 uL to B.\"\n      note \"Using the same pipette but a fresh tip, and solution IV to the tubes: 550 uL to A and 250 uL to B.\"\n      check \"Each tube should now have 1 mL (total volume) in it, so, to check the error from pipetting, set the 1 mL pipette to 1000 uL and draw up as much liquid as possible from each tube.\"\n    end\n    \n    calculate_error()\n    \n    show do\n      title \"Discard Tubes\"\n      check \"Throw out tubes A and B\"\n    end\n    \n    show do \n      title \"Small Volume Exercise\"\n    \n      note \"Take out tubes C - E, and the 10 uL pipette and pipette tip box.\"\n      note \"Add solution I to the tubes: 4 uL in in C, 4 uL in D, and 4 uL in E.\"\n      note \"Using the same pipette but a new tip, add solution II to the tubes: 5 uL to C, 5 uL to D, and 4 uL to E.\"\n      note \"Using the same pipette but a new tip, add solution III to the tuebs: 1 uL to C, and 1 uL to E.\"\n      note \"Using the same pipette but a new tip, add solution IV to the tubes: 1 uL to D and 1 uL to E.\"\n      note \"Each tube should now have 10 uL (total volume) in it, so to check the error from pipetting, set the 10 uL pipette to 10 uL and draw up as much liquid as possible from each tube.\"\n    end\n    \n    calculate_error()\n    \n    show do\n      title \"Discard Tubes\"\n      check \"Throw out tubes C, D, and E\"\n    end\n    \n    return {}\n\n  end\n  \n  \n  def calculate_error\n    choice = show do\n      title \"Calculate Measurement Error\"\n      bullet \"If there is still liquid left in the tube, too much was added.\"\n      bullet \"If there is air at the end of the tip, too little was added.\"\n      bullet \"If the tube is filled exactly with liquid, the measurement error is 0.\"\n      \n      select [\"Too much\", \"Too little\", \"Just right\"], var: \"choice\", label: \"How much liquid did you add?\", default: [0,1,2].sample\n    end.get_response(\"choice\")\n      \n    if choice == \"Too much\"\n      show do\n        title \"Calculate Measurement Error\"\n        note \"To determine the error if too much was added, follow thise steps:\"\n        check \"Discard the tip with liquid in it and get a fresh tip. \"\n        check \"Carefully pipette up the remaining liquid in the tip, and then rotate the volume dial until the liquid reaches the bottom of the tip.\" \n        note \"The error rate is (new volume / total volume)\"\n      end\n    elsif choice == \"Too little\"\n      show do\n        title \"Calculate Measurement Error\"\n        note \"To determine the error if too little was added, follow thise steps:\"\n        check \"Slowly decrease the volume until the liquid reaches the end of the tip.\"\n        note \"The error rate is ((total volume - new volume) / total volume)\"\n      end\n    else\n      show do\n        title \"Calculate Measurement Error\"\n        note \"If the tube is filled exactly with liquid, the measurement error is 0.\"\n        note \"Try again and mess up more so that you can practice calculating measurement error!\"\n      end\n    end\n  end\nend\n\n\n\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"","timing":null}},{"sample_types":[{"id":1,"name":"OLASimple Sample","description":"Patient sample and OLA kit","created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","field_types":[{"id":1,"parent_id":1,"name":"Patient ID","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":2,"parent_id":1,"name":"Secondary Patient ID","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]}]}],"object_types":[{"id":3,"name":"OLA PCR","description":"OLA PCR","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","unit":"OLASimple Sample","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":null,"prefix":"","rows":null,"columns":null,"sample_type_name":"OLASimple Sample"},{"id":4,"name":"OLA Ligation Stripwell","description":"OLA Ligation Stripwell","min":0,"max":1,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","unit":"Well","cost":0.01,"release_method":"return","release_description":"","sample_type_id":null,"image":null,"prefix":"","rows":1,"columns":12,"sample_type_name":null}],"operation_type":{"name":"OLASimple Ligation","category":"OLASimple","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"PCR Product","sample_types":["OLASimple Sample"],"object_types":["OLA PCR"],"part":false,"array":false,"routing":"PP","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"Ligation Product","sample_types":["OLASimple Sample"],"object_types":["OLA Ligation Stripwell"],"part":false,"array":false,"routing":"PP","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"##########################################\n#\n#\n# OLASimple Ligation\n# author: Justin Vrana\n# date: March 2018\n#\n#\n##########################################\n\n\nneeds \"OLASimple/OLAConstants\"\nneeds \"OLASimple/OLALib\"\nneeds \"OLASimple/OLAGraphics\"\nneeds \"OLASimple/JobComments\"\nneeds \"OLASimple/OLAKitIDs\"\n\nclass Protocol\n  include OLALib\n  include OLAGraphics\n  include OLAConstants\n  include JobComments\n  include OLAKitIDs\n\n  ##########################################\n  # INPUT/OUTPUT\n  ##########################################\n  INPUT = \"PCR Product\"\n  OUTPUT = \"Ligation Product\"\n  PACK = \"Ligation Pack\"\n  A = \"Diluent A\"\n\n\n  ##########################################\n  # TERMINOLOGY\n  ##########################################\n\n  ##########################################\n  # Protocol Specifics\n  ##########################################\n\n  AREA = POST_PCR\n\n  # for debugging\n  PREV_COMPONENT = \"2\"\n  PREV_UNIT = \"A\"\n\n  CENTRIFUGE_TIME = \"5 seconds\" # time to pulse centrifuge to pull down dried powder\n  VORTEX_TIME = \"5 seconds\" # time to pulse vortex to mix\n  TUBE_CAP_WARNING = \"Check to make sure tube caps are completely closed.\"\n\n  PACK_HASH = {\n            \"Unit Name\" =\u003e \"L\",\n            \"Components\" =\u003e {\n                \"sample tubes\" =\u003e [\n                    \"1\",\n                    \"2\",\n                    \"3\",\n                    \"4\",\n                    \"5\",\n                    \"6\",\n                    \"7\"\n                ],\n                \"diluent A\" =\u003e \"0\"\n            },\n            \"PCR to Ligation Mix Volume\" =\u003e 1.2,\n            \"Ligation Mix Rehydration Volume\" =\u003e 24,\n            \"Number of Samples\" =\u003e 2,\n            \"Number of Sub Packages\" =\u003e 2\n        }\n\n  COLORS =  [\"red\", \"green\",\"yellow\", \"blue\", \"purple\", \"white\", \"gray\"]\n    \n  LIGATION_VOLUME = PACK_HASH[\"Ligation Mix Rehydration Volume\"]  # volume to rehydrate ligation mix\n  SAMPLE_VOLUME = PACK_HASH[\"PCR to Ligation Mix Volume\"] # volume of pcr product to ligation mix\n  MATERIALS =  [\n      \"P200 pipette and filtered tips\",\n      \"P10 pipette and filtered tips\",\n      \"a spray bottle of 10% v/v bleach\",\n      \"a spray bottle of 70% v/v ethanol\",\n      \"a timer, practice how to use the timer\",\n      \"balancing tube (on rack)\",\n      \"a centrifuge\",\n      \"a vortex mixer\",\n  ]\n  COMPONENTS = PACK_HASH[\"Components\"][\"sample tubes\"]\n\n  ##########################################\n  # ##\n  # Input Restrictions:\n  # Input needs a kit, unit, components,\n  # and sample data associations to work properly\n  ##########################################\n\n  def main\n    operations.running.retrieve interactive: false\n    save_user operations\n    debug_setup(operations) if debug\n    save_temporary_input_values(operations, INPUT)\n    # save_pack_hash(operations, PACK)\n    operations.each do |op|\n      op.temporary[:pack_hash] = PACK_HASH\n    end\n    save_temporary_output_values(operations)\n    run_checks operations\n    \n    expert_mode = ask_if_expert\n    \n    introduction(operations.running)\n    \n    area_preparation POST_PCR, MATERIALS, PRE_PCR\n    get_samples_from_thermocycler(operations.running)\n    get_ligation_packages(operations.running)\n    open_ligation_packages(operations.running)\n    check_for_tube_defects operations.running\n    centrifuge_samples sorted_ops.running\n    rehydrate_ligation_mix sorted_ops.running, expert_mode\n    vortex_and_centrifuge_samples sorted_ops.running\n    add_template sorted_ops.running, expert_mode\n    vortex_and_centrifuge_samples sorted_ops.running\n    cleanup sorted_ops\n    start_ligation sorted_ops.running\n    conclusion sorted_ops\n    accept_comments\n    return {}\n  end\n \n  def sorted_ops\n    operations.sort_by {|op| op.output_ref(OUTPUT)}.extend(OperationList)\n  end\n\n  def save_user ops\n    ops.each do |op|\n      username = get_technician_name(self.jid)\n      op.associate(:technician, username)\n    end\n  end\n\n  def debug_setup ops\n    # make an alias for the inputs\n    if debug\n      ops.each_with_index do |op, i|\n        kit_num = \"001\"\n        sample_num = sample_num_to_id(i + 1)\n        make_alias(op.input(INPUT).item, kit_num, PREV_UNIT, PREV_COMPONENT, 'a patient id' , sample_num)\n      end\n    end\n  end\n\n  def run_checks myops\n    if operations.running.empty?\n      show do\n        title \"All operations have errored\"\n        note \"Contact #{SUPERVISOR}\"\n        operations.each do |op|\n          note \"#{op.errors.map {|k, v| [k, v]}}\"\n        end\n      end\n      return {}\n    end\n  end\n  \n  def ask_if_expert\n    resp = show do\n      title \"Expert Mode?\"\n      note \"Are you an expert at this protocol? If you do not know what this means, then continue without enabling expert mode.\"\n      select [\"Continue in normal mode\", \"Enable expert mode\"], var: :choice, label: \"Expert Mode?\", default: 0\n    end\n    return resp[:choice] == \"Enable expert mode\"\n  end\n\n  def introduction ops\n    kit_nums = ops.map {|op| op.input(INPUT).item.get(KIT_KEY)}.uniq\n    samples = \"#{ops.length} #{\"sample\".pluralize(ops.length)}\"\n    kits = \"#{kit_nums.length} #{\"kit\".pluralize(kit_nums.length)}\"\n    username = get_technician_name(self.jid).color(\"darkblue\")\n    show do\n      title \"Welcome #{username} to OLASimple Ligation\"\n      note \"You will be running the OLASimple Ligation protocol\"\n      note \"In this protocol you will be using PCR samples from the last protocol\" \\\n            \" and adding small pieces of DNA which will allow you to detect HIV mutations.\"\n      note \"You will be running #{samples} from #{kits}.\"\n      check \"OLA Ligation is highly sensitive. Small contamination can cause false positive. Before proceed, please check with your assigner if the space and pipettes have been wiped with 10% bleach and 70% ethanol.\"\n      check \"Put on tight gloves. Tight gloves help reduce contamination risk\"\n      note \"Click \u003cb\u003eOK\u003c/b\u003e in the upper right corner to start the protocol.\"\n    end\n  end\n\n  def get_ligation_packages myops\n    gops = myops.group_by { |op| op.temporary[:output_kit_and_unit] }\n    show do\n      title \"Take #{LIG_PKG_NAME.pluralize(gops.length)} from the R1 #{FRIDGE_POST} \"\n      gops.each do |unit, ops|\n        check \"#{PACKAGE_POST} #{unit.bold}\"\n      end\n      check \"Place #{pluralizer(PACKAGE_POST, gops.length)} on the #{BENCH_POST} in the #{AREA.bold}.\"\n      check \"Put on a new pair of gloves\"\n    end\n  end\n\n  def open_ligation_packages(myops)\n    grouped_by_unit = operations.running.group_by {|op| op.temporary[:output_kit_and_unit]}\n    grouped_by_unit.each do |kit_and_unit, ops|\n      ops.each do |op|\n        op.make_collection_and_alias(OUTPUT, \"sample tubes\", INPUT)\n      end\n\n      ops.each do |op|\n        op.temporary[:label_string] = \"#{op.output_refs(OUTPUT)[0]} through #{op.output_refs(OUTPUT)[-1]}\"\n      end\n\n\n      ##################################\n      # get output collection references\n      #################################\n\n\n      show_open_package(kit_and_unit, \"\", ops.first.temporary[:pack_hash][NUM_SUB_PACKAGES_FIELD_VALUE]) do\n          tube = make_tube(closedtube, \"\", ops.first.tube_label(\"diluent A\"), \"medium\")\n          num_samples = ops.first.temporary[:pack_hash][NUM_SAMPLES_FIELD_VALUE]\n          grid = SVGGrid.new(1, num_samples, 0, 100)\n          tokens = ops.first.output_tokens(OUTPUT)\n          ops.each_with_index do |op, i|\n            _tokens = tokens.dup\n            _tokens[-1] = op.temporary[:input_sample]\n            ligation_tubes = display_ligation_tubes(*_tokens, COLORS)\n            stripwell = ligation_tubes.g\n            grid.add(stripwell, 0, i)\n          end\n          grid.align_with(tube, 'center-right')\n          grid.align!('center-left')\n          img = SVGElement.new(children: [tube, grid], boundx: 1000, boundy: 300).translate!(30, -50)\n        note \"Check that the following tubes are in the pack:\"\n        # check \"a 1.5mL tube of #{DILUENT_A} labeled #{ops.first.ref(\"diluent A\")}\"\n        # ops.each do |op|\n        #   check \"a strip of colored tubes labeled #{op.temporary[:label_string].bold}\"\n        # end\n        note display_svg(img, 0.75)\n      end\n\n      show do\n        title \"Place strips of tubes into a rack\"\n        check \"Take #{pluralizer(\"tube strip\", ops.length)} and place them in the plastic racks\"\n      end\n    end\n  end\n\n  def centrifuge_samples ops\n    labels = ops.map {|op| op.temporary[:label_string] }\n    diluentALabels = ops.map { |op| op.ref(\"diluent A\") }.uniq\n    show do\n        title \"Centrifuge samples for 5 seconds to pull down reagents\"\n        note \"Put the tag side of the rack toward the center of the centrifuge\"\n        image \"Actions/OLA/striptubes_in_centrifuge.JPG\"\n    end\n    # centrifuge_helper(\"tube set\", labels, CENTRIFUGE_TIME,\n    #                   \"to pull down dried powder.\",\n    #                   \"There may be dried powder on the inside of the tube #{\"lid\".pluralize(labels.length)}.\")\n    # centrifuge_helper(\"tube\", diluentALabels, CENTRIFUGE_TIME,\n    #                   \"to pull down liquid.\")\n  end\n  \n  def vortex_and_centrifuge_samples ops\n         labels = ops.map {|op| op.temporary[:label_string] }\n         vortex_and_centrifuge_helper(\"tube set\", labels, CENTRIFUGE_TIME, VORTEX_TIME,\n                      \"to mix.\", \"to pull down the fluid.\", AREA)\n    show do\n        title \"Check your tubes.\" \n        check \"Dried powder of reagents should be dissolved at this point. Look on the side of the tubes to check if you see any remaining powder. If you notice any powder remains on the side, rotate the tubes while vortexing for 5 seconds and centrifuge for 5 seconds.\"\n        check \"All the tubes should have similar fluid levels. Check again if you have any cracked tubes that could cause fluid leakage. If you have a cracked tube, notify the assigner. We will replace a new tube for you.\"\n    end\n  end\n  \n  def get_samples_from_thermocycler myops\n      show do\n          title \"Retrieve PCR samples from the #{THERMOCYCLER} or freezer\"\n          check \"If your samples were stored in the freezer, get samples from the M20 freezer, 4th shelf down in the red box.Thaw samples.\"\n          check \"Else, if your samples are in the #{THERMOCYCLER}, cancel the run if the machine says \\\"hold at 4C\\\", and get your samples.\"\n          check \"Vortex and centrifuge samples for 5 seconds.\"\n      end\n  end\n\n  def rehydrate_ligation_mix myops, expert_mode\n    gops = myops.group_by {|op| op.temporary[:input_kit_and_unit]}\n    gops.each do |unit, ops|\n      ops.each do |op|\n        labels = op.output_refs(OUTPUT)\n        if expert_mode\n        # All transfers at once...\n          from = op.ref(\"diluent A\")\n          tubeA = make_tube(opentube, [DILUENT_A, from], op.tube_label(\"diluent A\"), \"medium\")\n          show do\n            title \"Add #{DILUENT_A} #{from} to #{LIGATION_SAMPLE}s #{op.temporary[:label_string].bold}\"\n            labels.map! {|l| \"\u003cb\u003e#{l}\u003c/b\u003e\"}\n            note \"In this step we will be adding #{LIGATION_VOLUME}uL of #{DILUENT_A} #{from} into #{pluralizer(\"tube\", COMPONENTS.length)} \"\n            \"of the colored strip of tubes labeled \u003cb\u003e#{labels[0]} to #{labels[-1]}\u003c/b\u003e\"\n            note \"Using a P200 pipette, add #{LIGATION_VOLUME}uL from #{DILUENT_A} #{from} into each of the #{COMPONENTS.length} tubes.\"\n            warning \"Only open one of the ligation tubes at a time.\"\n\n            ligation_tubes = display_ligation_tubes(*op.output_tokens(OUTPUT), COLORS).translate!(0, -20)\n\n            transfer_image = make_transfer(tubeA, ligation_tubes, 200, \"#{LIGATION_VOLUME}uL\", \"(#{P200_POST} pipette)\" )\n            note display_svg(transfer_image, 0.6)\n\n            # t = Table.new\n            # t.add_column(\"Tube\", labels)\n            # t.add_column(\"Color\", COMPONENTS_COLOR_CODE)\n            # table t\n          end\n        else\n          # each transfer\n          from = op.ref(\"diluent A\")\n          ligation_tubes = display_ligation_tubes(*op.output_tokens(OUTPUT), COLORS)\n          ligation_tubes.align!('bottom-left')\n          ligation_tubes.align_with(tube, 'bottom-right')\n          ligation_tubes.translate!(50)\n          tubeA = make_tube(closedtube, DILUENT_A, op.tube_label(\"diluent A\"), \"medium\")\n          image = SVGElement.new(children: [tubeA, ligation_tubes], boundx: 1000, boundy: tube.boundy)\n          image.translate!(50, -50)\n          show do\n            title \"Position #{DILUENT_A} #{from.bold} and colored tubes #{op.temporary[:label_string].bold} in front of you.\"\n            note \"In the next steps you will dissolve the powder in #{pluralizer(\"tube\", COMPONENTS.length)} using #{DILUENT_A}\"\n            note display_svg(image, 0.75)\n          end\n          ligation_tubes_svg = display_ligation_tubes(*op.output_tokens(OUTPUT), COLORS).translate!(0, -20)\n          img = display_svg(ligation_tubes_svg, 0.7)\n          # centrifuge_helper(LIGATION_SAMPLE, op.temporary[:labels], CENTRIFUGE_TIME, \"to pull down dried powder.\", img)\n  \n          labels.each.with_index do |label, i|\n            show do\n              raw transfer_title_proc(LIGATION_VOLUME, from, label)\n              # title \"Add #{LIGATION_VOLUME}uL #{DILUENT_A} #{from.bold} to #{LIGATION_SAMPLE} #{label}\n              warning \"Change pipette tip between tubes\"\n              note \"Set a #{P200_POST} pipette to [0 2 4].\" \n              note \"Add #{LIGATION_VOLUME}uL from #{from.bold} into tube #{label.bold}\"\n              note \"Close tube #{label.bold}\"\n              tubeA = make_tube(opentube, [DILUENT_A, from], \"\", \"medium\")\n              transfer_image = transfer_to_ligation_tubes_with_highlight(\n                  tubeA, i, *op.output_tokens(OUTPUT), COLORS, LIGATION_VOLUME, \"(#{P200_POST} pipette)\")\n              note display_svg(transfer_image, 0.6)\n            end\n          end\n        end\n        # vortex_and_centrifuge_helper(LIGATION_SAMPLE,\n        #                              op.temporary[:labels],\n        #                              VORTEX_TIME,\n        #                              CENTRIFUGE_TIME,\n        #                              \"to mix well.\",\n        #                              \"to pull down liquid.\",\n        #                              img)\n\n\n        # show do\n        #   title \"Mix ligation tubes #{op.temporary[:labels][0]} through #{op.temporary[:labels][-1]}\"\n        #   note display_svg(display_ligation_tubes(op.temporary[:input_kit], THIS_UNIT, COMPONENTS, op.temporary[:input_sample]), 0.5)\n        #   warning \"Make sure tubes are firmly closed before proceeding.\"\n        #   check \"Vortex #{pluralizer(\"tube\", COMPONENTS.length)} for 5 seconds to mix well.\"\n        #   warning \"Make sure all powder is dissolved. Vortex for 10 more seconds to dissolve powder.\"\n        #   check \"Centrifuge #{pluralizer(\"tube\", COMPONENTS.length)} for 5 seconds to pull down liquid.\"\n        #   check \"Place tubes back into the rack.\"\n        # end\n      end\n    end\n\n    # vortex_and_centrifuge_helper(\"tube set\",\n    #                              myops.map { |op| op.temporary[:label_string] },\n    #                              VORTEX_TIME,\n    #                              CENTRIFUGE_TIME,\n    #                              \"to mix well.\",\n    #                              \"to pull down liquid.\")\n  end\n\n  def add_template myops, expert_mode\n\n    show do\n      title \"Get #{PCR_SAMPLE.pluralize(myops.length)} from #{THERMOCYCLER}\"\n      note \"If thermocycler run is complete (infinite hold at 4C), hit cancel followed by yes. Take #{PCR_SAMPLE.pluralize(myops.length)} #{myops.map { |op| ref(op.input(INPUT).item).bold}.join(', ')} from the #{THERMOCYCLER}\"\n      note \"If they have been stored, retrieve PCR samples from M20 4th shelf down red box and thaw\"\n      check \"Position #{PCR_SAMPLE.pluralize(myops.length)} on #{BENCH_POST} in front of you.\"\n      centrifuge_proc(PCR_SAMPLE, myops.map { |op| ref(op.input(INPUT).item) }, \"3 seconds\", \"to pull down liquid.\", AREA, balance = false)\n    end\n\n    gops = myops.group_by {|op| op.temporary[:input_kit_and_unit]}\n    gops.each do |unit, ops|\n      ops.each do |op|\n        from = op.input_ref(INPUT)\n        if expert_mode\n        # All transfers at once...\n          show do\n            raw transfer_title_proc(SAMPLE_VOLUME, from, op.temporary[:label_string])\n            warning \"Change of pipette tip between tubes\"\n            note \"Using a #{P20_POST} pipette set to [0 1 2], add #{SAMPLE_VOLUME}uL from #{from.bold} into each of #{op.temporary[:label_string].bold}.\"\n            note \"Only open one ligation tube at a time.\"\n            \n            tubeP = make_tube(opentube, [\"PCR Sample\"], op.input_tube_label(INPUT), \"small\").scale(0.75)\n            ligation_tubes = display_ligation_tubes(*op.output_tokens(OUTPUT), COLORS).translate!(0, -20)\n            transfer_image = make_transfer(tubeP, ligation_tubes, 200, \"#{SAMPLE_VOLUME}uL\", \"(#{P20_POST} pipette)\" )\n            \n            note display_svg(transfer_image, 0.6)\n\n          end\n        else\n          show do\n            title \"Position #{PCR_SAMPLE} #{from.bold} and #{LIGATION_SAMPLE.pluralize(COMPONENTS.length)} #{op.temporary[:label_string].bold} in front of you.\"\n            note \"In the next steps you will add #{PCR_SAMPLE} to #{pluralizer(\"tube\", COMPONENTS.length)}\"\n            tube = make_tube(closedtube, [PCR_SAMPLE, from], \"\", \"small\")\n            ligation_tubes = display_ligation_tubes(*op.output_tokens(OUTPUT), COLORS)\n            ligation_tubes.align!('bottom-left')\n            ligation_tubes.align_with(tube, 'bottom-right')\n            ligation_tubes.translate!(50)\n            image = SVGElement.new(children: [tube, ligation_tubes], boundx: 1000, boundy: tube.boundy)\n            image.translate!(50, -30)\n            note display_svg(image, 0.75)\n          end\n          labels = op.output_refs(OUTPUT)\n          labels.each.with_index do |label, i|\n            show do\n              raw transfer_title_proc(SAMPLE_VOLUME, from, label)\n              # title \"Add #{PCR_SAMPLE} #{from.bold} to #{LIGATION_SAMPLE} #{label}\"\n              warning \"Change of pipette tip between tubes\"\n              note \"Using a #{\"P10\"} pipette set to [0 1 2], add #{SAMPLE_VOLUME}uL from #{from.bold} into tube #{label.bold}\"\n              note \"Close tube #{label.bold}\"\n              tube = make_tube(opentube, [\"PCR Sample\"], op.input_tube_label(INPUT), \"small\").scale(0.75)\n              img = transfer_to_ligation_tubes_with_highlight(tube, i, *op.output_tokens(OUTPUT), COLORS, SAMPLE_VOLUME, \"(#{P20_POST} pipette)\")\n              note display_svg(img, 0.6)\n            end\n          end\n        end\n\n        # ligation_tubes_svg = display_ligation_tubes(*op.output_tokens(OUTPUT), COLORS)\n        # img = display_svg(ligation_tubes_svg, 0.7)\n        # vortex_and_centrifuge_helper(LIGATION_SAMPLE,\n        #                              op.output_refs(OUTPUT),\n        #                              VORTEX_TIME,\n        #                              CENTRIFUGE_TIME,\n        #                              \"to mix well.\",\n        #                              \"to pull down liquid.\",\n        #                              img)\n      end\n    end\n  end\n\n  def start_ligation myops\n    gops = myops.group_by {|op| op.temporary[:input_kit_and_unit]}\n    ops = gops.map {|unit, ops| ops}.flatten # organize by unit\n    # show do\n    #   title \"Place #{LIGATION_SAMPLE.pluralize(COMPONENTS.length)} into #{THERMOCYCLER}\"\n    #   check \"Place #{pluralizer(LIGATION_SAMPLE, ops.length * COMPONENTS.length)} (#{ops.length} #{\"set\".pluralize(ops.length)} of #{COMPONENTS.length})\" \\\n    #     \" in the #{THERMOCYCLER}\"\n    #   check \"Close and tighten the lid.\"\n    #   ops.each do |op|\n    #     note display_svg(display_ligation_tubes(*op.output_tokens(OUTPUT), COLORS), 0.5)\n    #   end\n    # end\n\n    add_to_thermocycler(\"sample\", ops.length * COMPONENTS.length, LIG_CYCLE, ligation_cycle_table, \"Ligation\")\n\n    show do\n      title \"Set a timer for 45 minutes\"\n      #   check \"Return to the #{PRE_PCR}.\"\n      check \"Find a timer and set it for 45 minutes. Continue to next step.\"\n    end\n  end\n\n  def ligation_cycle_table\n    t = Table.new()\n    cycles_temp = \"\u003ctable style=\\\"width:100%\\\"\u003e\n                        \u003ctr\u003e\u003ctd\u003e95C\u003c/td\u003e\u003c/tr\u003e\n                        \u003ctr\u003e\u003ctd\u003e37C\u003c/td\u003e\u003c/tr\u003e\n          \u003c/table\u003e\"\n    cycles_time = \"\u003ctable style=\\\"width:100%\\\"\u003e\n                        \u003ctr\u003e\u003ctd\u003e30 sec\u003c/td\u003e\u003c/tr\u003e\n                        \u003ctr\u003e\u003ctd\u003e4 min\u003c/td\u003e\u003c/tr\u003e\n          \u003c/table\u003e\"\n    # t.add_column(\"STEP\", [\"Initial Melt\", \"10 cycles of\", \"Hold\"])\n    t.add_column(\"TEMP\", [\"95C\", cycles_temp, \"4C\"])\n    t.add_column(\"TIME\", [\"4 min\", cycles_time, \"forever\"])\n    t\n  end\n\n  def cleanup myops\n\n    items = [INPUT].map {|x| myops.map {|op| op.input(x)}}.flatten.uniq\n    item_refs = [INPUT].map {|x| myops.map {|op| op.input_ref(x)}}.flatten.uniq\n    if KIT_NAME == \"uw kit\"\n        item_refs = [] \n    end\n    temp_items = [\"diluent A\"].map {|x| myops.map {|op| op.ref(x)}}.flatten.uniq\n\n    all_refs = temp_items + item_refs\n\n    show do\n      title \"Throw items into the #{WASTE_POST}\"\n\n      note \"Throw the following items into the #{WASTE_POST} in the #{AREA}\"\n      t = Table.new\n      t.add_column(\"Tube\", all_refs)\n      table t\n    end\n    # clean_area AREA\n  end\n\n  def conclusion myops\n    if KIT_NAME == \"uw kit\"\n        show do\n            title \"Please return PCR products\"\n            check \"Place #{\"sample\".pluralize(myops.length)} #{myops.map { |op| op.input_ref(INPUT) }.join(', ')} in the M20 4th shelf down in the corresponding red box labeled #{\"STORED USED 1B - 24B\".quote.bold} or #{\"STORE USED 25B - 48B\".quote.bold}.\"\n            image \"Actions/OLA/map_Klavins.svg \"\n        end\n    end\n    show do\n      title \"Thank you!\"\n      warning \"\u003ch2\u003eYou must click #{\"OK\".quote.bold} to complete the protocol\u003c/h2\u003e\"\n      check \" After clicking #{\"OK\".quote.bold}, discard your gloves and wash your hands with soap. \"\n      note \"The #{THERMOCYCLER} will be done in 50 minutes.\"\n    end\n\n  end\nend","precondition":"eval Library.find_by_name(\"OLAScheduling\").code(\"source\").content\nextend OLAScheduling\n\ndef precondition(op)\n  schedule_same_kit_ops(op)\n  true\nend","cost_model":"def cost(op)\n  { labor: 7.5, materials: 0 }\nend","documentation":"Add small pieces of DNA to the PCR product from OLASimple PCR that allow detection of HIV mutations.","test":"","timing":null}},{"sample_types":[{"id":1,"name":"OLASimple Sample","description":"Patient sample and OLA kit","created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","field_types":[{"id":1,"parent_id":1,"name":"Patient ID","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":2,"parent_id":1,"name":"Secondary Patient ID","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]}]}],"object_types":[{"id":5,"name":"OLA viral RNA","description":"RNA extracted from patient plasma","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","unit":"OLASimple Sample","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":null,"prefix":"","rows":null,"columns":null,"sample_type_name":"OLASimple Sample"},{"id":3,"name":"OLA PCR","description":"OLA PCR","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","unit":"OLASimple Sample","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":null,"prefix":"","rows":null,"columns":null,"sample_type_name":"OLASimple Sample"}],"operation_type":{"name":"OLASimple PCR","category":"OLASimple","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Patient Sample","sample_types":["OLASimple Sample"],"object_types":["OLA viral RNA"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"PCR Product","sample_types":["OLASimple Sample"],"object_types":["OLA PCR"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"##########################################\n#\n#\n# OLASimple PCR\n# author: Justin Vrana\n# date: March 2018\n#\n#\n##########################################\n\nneeds \"OLASimple/OLAConstants\"\nneeds \"OLASimple/OLALib\"\nneeds \"OLASimple/OLAGraphics\"\n\n# TODO: There should be NO calculations in the show blocks\n\nclass Protocol\n  include OLAConstants\n  include OLALib\n  include OLAGraphics\n\n  ##########################################\n  # INPUT/OUTPUT\n  ##########################################\n  INPUT = \"Patient Sample\"\n  OUTPUT = \"PCR Product\"\n  PACK = \"PCR Pack\"\n  A = \"Diluent A\"\n\n  ##########################################\n  # TERMINOLOGY\n  ##########################################\n\n  ##########################################\n  # Protocol Specifics\n  ##########################################\n\n\n  # TUBE LABELS ARE DIFF FOR NUTTADA\n  # Nuttada: Introduction NO CELL LYSATE OR MENTION BLOOD (USE NONINFECTION SYNTHETIC DNA)\n  # use only P200 pipette\n  # change to P20 pipette\n  # eliminate 10% bleach / 70% ethanol\n  # eliminate timer from materials list\n  # NUTTADA: R1 fridge, name pre-pcr bench\n  # \"Tear open package. There are two section. Tear open both \"\n  # throw error if two operations have same input item\n  # change transfer images to P200\n  # centrifuge sample after vortexing (after pcr rehydration)\n  # Nuttada: cell lysate \u003e DNA sample\n\n  # Manually put in pack hash...\n  PACK_HASH = {\n      \"Unit Name\" =\u003e \"A\",\n      \"Components\" =\u003e {\n          \"sample tube\" =\u003e \"2\",\n          \"diluent A\" =\u003e \"1\"\n      },\n      \"PCR Rehydration Volume\" =\u003e 40,\n      \"Number of Samples\" =\u003e 2,\n      \"Number of Sub Packages\" =\u003e 2,\n  }\n\n  AREA = PRE_PCR\n  SAMPLE_VOLUME = 10 # volume of sample to add to PCR mix\n  PCR_MIX_VOLUME = PACK_HASH[\"PCR Rehydration Volume\"] # volume of water to rehydrate PCR mix in\n  CENTRIFUGE_TIME = \"5 seconds\" # time to pulse centrifuge to pull down dried powder\n  VORTEX_TIME = \"5 seconds\" # time to pulse vortex to mix\n\n  # for debugging\n  PREV_COMPONENT = \"\"\n  PREV_UNIT = \"E\"\n\n\n  TUBE_CAP_WARNING = \"Check to make sure tube caps are completely closed.\"\n\n  component_to_name_hash = {\n      \"diluent A\" =\u003e \"Diluent A\",\n      \"sample tube\" =\u003e \"PCR sample\"\n  }\n\n  MATERIALS = [\n      \"P200 pipette and filtered tips\",\n      \"P20 pipette and filtered tips\",\n      \"a timer\",\n      \"nitrile gloves (wear tight gloves to reduce contamination risk)\",\n      \"pre-PCR rack\",\n      \"a balancing tube (on rack)\",\n      \"biohazard waste (red bag)\",\n      \"vortex\",\n      \"centrifuge\",\n  ]\n  \n  \n  SAMPLE_ALIAS = \"RNA Extract\"\n\n  ##########################################\n  # ##\n  # Input Restrictions:\n  # Input needs a kit, unit, components,\n  # and sample data associations to work properly\n  ##########################################\n\n\n  def main\n\n\n    operations.running.retrieve interactive: false\n    operations.running.make\n    save_user operations\n    debug_setup(operations) if debug\n    \n    \n    if debug\n        labels = ['001','002']\n        operations.each.with_index do |op, i|\n            op.input(INPUT).item.associate(SAMPLE_KEY, labels[i])  \n            op.input(INPUT).item.associate(COMPONENT_KEY, \"6\")\n            op.input(INPUT).item.associate(UNIT_KEY, PREV_UNIT)\n        end\n    end\n    \n    \n    save_temporary_input_values(operations, INPUT)\n    operations.each do |op|\n      op.temporary[:pack_hash] = PACK_HASH\n    end\n    save_temporary_output_values(operations)\n\n    \n    run_checks operations\n    kit_introduction operations.running\n    area_preparation \"pre-PCR\", MATERIALS, POST_PCR\n    get_inputs operations.running\n    get_pcr_packages operations.running\n    open_pcr_packages operations.running\n    debug_table operations.running\n    check_for_tube_defects sorted_ops.running\n    # nuttada thaw\n    # nuttada needs vortex + centrigure\n    centrifuge_samples sorted_ops.running\n    resuspend_pcr_mix sorted_ops.running\n    add_template_to_master_mix sorted_ops.running\n    cleanup sorted_ops\n    start_thermocycler sorted_ops.running\n    conclusion sorted_ops\n    return {}\n  end # main\n\n  # end of main\n\n\n  #######################################\n  # Utilities\n  #######################################\n  def save_user ops\n    ops.each do |op|\n      username = get_technician_name(self.jid)\n      op.associate(:technician, username)\n    end\n  end\n\n  def debug_setup ops\n    # make an alias for the inputs\n    if debug\n      ops.each do |op|\n        kit_num = rand(1..60)\n        make_alias(op.input(INPUT).item, kit_num, PREV_UNIT, PREV_COMPONENT, 1)\n        # op.input(PACK).item.associate(KIT_KEY, kit_num)\n      end\n\n      if ops.length \u003e= 2\n        i = ops[-1].input(INPUT).item\n        alias_array = get_alias_array(i)\n        alias_array[3] = if (alias_array[3] == 1) then\n                           2\n                         else\n                           1\n                         end\n        make_alias(ops[0].input(INPUT).item, *alias_array)\n\n        # kit_num = ops[-1].input(PACK).item.get(KIT_KEY)\n        # ops[0].input(PACK).item.associate(KIT_KEY, kit_num)\n      end\n    end\n  end\n\n  def run_checks myops\n    if operations.running.empty?\n      show do\n        title \"All operations have errored\"\n        note \"Contact #{SUPERVISOR}\"\n        operations.each do |op|\n          note \"#{op.errors.map {|k, v| [k, v]}}\"\n        end\n      end\n      return {}\n    end\n  end\n\n  def sorted_ops\n    operations.sort_by {|op| op.output_ref(OUTPUT)}.extend(OperationList)\n  end\n\n  #######################################\n  # Instructions\n  #######################################\n \n  def kit_introduction ops\n    username = get_technician_name(self.jid).color(\"darkblue\")\n    kit_nums = ops.map {|op| op.input(INPUT).item.get(KIT_KEY)}.uniq\n    samples = \"#{ops.length} #{\"sample\".pluralize(ops.length)}\"\n    kits = \"#{kit_nums.length} #{\"kit\".pluralize(kit_nums.length)}\"\n    show do\n      title \"Welcome #{username} to OLASimple PCR\"\n      note \"You will be running the OLASimple PCR protocol. In this protocol, you will start with non-infectious, synthetic DNA. \" \\\n           \"You will generate PCR products from the samples and use them later to detect HIV mutations.\"\n     check \"OLASimple PCR assay is highly sensitive. If the space is not clean, this could cause false positive. Before proceeding this step, check with your assigner if the space and pipettes have been wiped with 10% bleach and 70% ethanol\"\n      note \"You will be running #{samples} from #{kits}.\"\n      note \"Click \u003cb\u003eOK\u003c/b\u003e in the upper right corner to start the protocol.\"\n    end\n  end\n  \n  def kenya_kit_introduction ops\n    username = get_technician_name(self.jid).color(\"darkblue\")\n    kit_nums = ops.map {|op| op.input(INPUT).item.get(KIT_KEY)}.uniq\n    samples = \"#{ops.length} #{\"sample\".pluralize(ops.length)}\"\n    kits = \"#{kit_nums.length} #{\"kit\".pluralize(kit_nums.length)}\"\n    show do\n      title \"Welcome #{username} to OLASimple PCR\"\n      note \"You will be running the OLASimple PCR protocol. In this protocol, you will start with #{CELL_LYSATE}. \" \\\n           \"You will generate PCR products from the samples and use them later to detect HIV mutations.\"\n      note \"You will be running #{samples} from #{kits}.\"\n      note \"Click \u003cb\u003eOK\u003c/b\u003e in the upper right corner to start the protocol.\"\n    end\n  end\n\n  def get_inputs myops\n    show do\n      title \"Place #{SAMPLE_ALIAS.bold} samples in #{AREA.bold}.\"\n    \n      note \"Place the following #{SAMPLE_ALIAS.bold} samples into a rack in the #{AREA.bold} area.\"\n      t = Table.new\n      t.add_column(\"Tube\", myops.map {|op| ref(op.input(INPUT).item)})\n      table t\n      # check \"Wipe with a #{WIPE}\"\n    end\n  end\n\n  def get_pcr_packages myops\n    # TODO: remove all references to 4C fridge and replace with refridgerator\n    gops = group_packages(myops)\n    show do\n      title \"Take #{PCR_PKG_NAME.pluralize(gops.length)} from the #{FRIDGE_PRE} and place on the #{BENCH_PRE} in the #{AREA}\"\n      # check \"Take the following from the #{FRIDGE} and place #{pluralizer(PACKAGE, gops.length)} on the #{BENCH}\"\n      gops.each do |unit, ops|\n        check \"Take \" \"#{PACKAGE_PRE} #{unit.bold}\" \" from fridge.\"\n        check \"Place \" \"#{PACKAGE_PRE} #{unit.bold}\" \" on the bench.\" \n        check \"Put on a new pair of gloves. Your gloves might have picked up some DNA that could contaminate your assay.\"\n      end\n    end\n  end\n\n  def open_pcr_packages myops\n    grouped_by_unit = myops.group_by {|op| op.temporary[:output_kit_and_unit]}\n    grouped_by_unit.each do |kit_and_unit, ops|\n      ops.each do |op|\n        op.make_item_and_alias(OUTPUT, \"sample tube\", INPUT)\n      end\n\n\n\n      show_open_package(kit_and_unit, \"\", ops.first.temporary[:pack_hash][NUM_SUB_PACKAGES_FIELD_VALUE]) do\n          # img\n          pcr_tube_labels = ops.map {|op| op.output_tube_label(OUTPUT)}\n          \n          num_samples = ops.first.temporary[:pack_hash][NUM_SAMPLES_FIELD_VALUE]\n          kit, unit, component, sample = ops.first.output_tokens(OUTPUT)\n          # diluentATube = label_tube(closedtube, tube_label(kit, unit, diluentAcomponent, \"\"))\n          diluentATube = self.make_tube(closedtube, \"Diluent A\", ops.first.tube_label(\"diluent A\"), \"medium\", true)\n    \n          grid = SVGGrid.new(num_samples, 1, 75, 10)\n          pcr_tube_labels.each_with_index do |tube_label, i|\n            pcrtube = self.make_tube(closedtube, \"\", tube_label, \"powder\", true).scale(0.75)\n            grid.add(pcrtube, i, 0)\n          end\n          grid.boundy = closedtube.boundy * 0.75\n          grid.align_with(diluentATube, 'center-right')\n          grid.align!('center-left')\n          grid.translate!(25, 25)\n          img = SVGElement.new(children: [diluentATube, grid], boundy: diluentATube.boundy + 50, boundx: 300).translate!(20)\n        \n        check \"Look for #{num_samples + 1} #{\"tube\".pluralize(num_samples)}\"\n        check \"Place tubes on a rack\"\n        note display_svg(img, 0.75)\n      end\n    end\n  end\n\n  def debug_table myops\n    if debug\n      show do\n        title \"DEBUG: I/O Table\"\n\n        table myops.running.start_table\n                  .custom_column(heading: \"Input Kit\") {|op| op.temporary[:input_kit]}\n                  .custom_column(heading: \"Output Kit\") {|op| op.temporary[:output_kit]}\n                  .custom_column(heading: \"Input Unit\") {|op| op.temporary[:input_unit]}\n                  .custom_column(heading: \"Output Unit\") {|op| op.temporary[:output_unit]}\n                  .custom_column(heading: \"Diluent A\") {|op| op.ref(\"diluent A\")}\n                  .custom_column(heading: \"Input Ref\") {|op| op.input_ref(INPUT)}\n                  .custom_column(heading: \"Output Ref\") {|op| op.output_ref(OUTPUT)}\n                  .end_table\n      end\n    end\n  end\n\n  def centrifuge_samples ops\n    labels = ops.map {|op| ref(op.output(OUTPUT).item)}\n    diluentALabels = ops.map {|op| op.ref(\"diluent A\")}\n    show do\n        title \"Obtain samples from your assigner.\"\n        check \"Do the samples match your kit number?\"\n        check \"Vortex sample tubes for 5 seconds.\"\n    end\n    show do\n        title \"Centrifuge all samples for 5 seconds\" \n        check \"Place diluent A (BB), balancing tube, PCR dried reagents (BA1, BA2), and DNA samples (AA and AB) in the centrifuge. It is important to balance all the tubes.\"\n        image \"Actions/OLA/centrifuge.svg\"\n        check \"Centrifuge the tubes for 5 seconds to pull down liquid and dried reagents\"\n    end\n    # centrifuge_helper(\"sample\", labels, CENTRIFUGE_TIME,\n    #                   \"to pull down dried powder.\",\n    #                   \"There may be dried powder on the inside of the tube #{\"lid\".pluralize(labels.length)}.\")\n    # centrifuge_helper(\"tube\", diluentALabels, CENTRIFUGE_TIME,\n    #                   \"to pull down liquid.\")\n  end\n\n  def resuspend_pcr_mix myops\n    gops = group_packages(myops)\n    gops.each do |unit, ops|\n      from = ops.first.ref(\"diluent A\")\n      ops.each do |op|\n        to_item = op.output(OUTPUT).item\n        to = ref(to_item)\n        tubeA = make_tube(opentube, [DILUENT_A, from], \"\", fluid = \"medium\")\n        tubeP = make_tube(opentube, [PCR_SAMPLE, to], \"\", fluid = \"powder\").scale!(0.75)\n        img = make_transfer(tubeA, tubeP, 250, \"#{PCR_MIX_VOLUME}uL\", \"(#{P200_PRE} pipette)\")\n        img.translate!(25)\n        show do\n          raw transfer_title_proc(PCR_MIX_VOLUME, from, to)\n          # title \"Add #{PCR_MIX_VOLUME}uL from #{DILUENT_A} #{from.bold} to #{PCR_SAMPLE} #{to.bold}\"\n          note \"#{DILUENT_A} will be used to dissolve the powder in the #{PCR_SAMPLE}.\"\n          note \"Use a #{P200_PRE} pipette and set it to [0 4 0].\"\n          note \"Avoid touching the inside of the lid, as this could cause contamination. \"\n          note \"Dispose of pipette tip.\"\n          note display_svg(img, 0.75)\n        end\n      end\n\n      # TODO: add \"make sure tube caps are completely closed\" for any centrifugation or vortexing step.\n      #\n    end\n\n    labels = myops.map {|op| ref(op.output(OUTPUT).item)}\n    vortex_and_centrifuge_helper(\"sample\",\n                                 labels,\n                                 VORTEX_TIME, CENTRIFUGE_TIME,\n                                 \"to mix.\", \"to pull down liquid\", AREA, mynote = nil)\n\n  end\n\n  def add_template_to_master_mix myops\n    gops = group_packages(myops)\n\n    gops.each do |unit, ops|\n      samples = ops.map {|op| op.input(INPUT).item}\n      sample_refs = samples.map {|sample| ref(sample)}\n      ops.each do |op|\n        from = ref(op.input(INPUT).item)\n        to = ref(op.output(OUTPUT).item)\n        show do\n          raw transfer_title_proc(SAMPLE_VOLUME, \"#{SAMPLE_ALIAS} #{from}\", \"#{PCR_SAMPLE} #{to}\")\n          warning \"\u003ch1\u003eLabels look very similar. Read the label three times before proceeding.\u003ch1\\\u003e\"\n          note \"Carefully open tube #{from.bold} and tube #{to.bold}\"\n          note \"Use a #{P20_PRE} pipette and set it to [1 0 0].\"\n          warning \"Close both tubes and dispose of pipette tip.\"\n          tubeS = make_tube(opentube, [SAMPLE_ALIAS, from], \"\", fluid = \"medium\")\n          tubeP = make_tube(opentube, [PCR_SAMPLE, to], \"\", fluid = \"medium\").scale!(0.75)\n          img = make_transfer(tubeS, tubeP, 250, \"#{SAMPLE_VOLUME}uL\", \"(#{P20_PRE} pipette)\")\n          img.translate!(25)\n          note display_svg(img, 0.75)\n\n        end\n      end\n    end\n  end\n\n  def start_thermocycler ops\n    # Adds the PCR tubes to the PCR machine.\n    # Instructions for PCR cycles.\n    #\n    samples = ops.map {|op| op.output(OUTPUT).item}\n    sample_refs = samples.map {|sample| ref(sample)}\n\n    # END OF PRE_PCR PROTOCOL\n\n    vortex_and_centrifuge_helper(PCR_SAMPLE,\n                                 ops.map {|op| ref(op.output(OUTPUT).item)},\n                                 VORTEX_TIME, CENTRIFUGE_TIME,\n                                 \"to mix.\", \"to pull down liquid\", AREA, mynote = nil)\n\n    t = Table.new()\n    cycles_temp = \"\u003ctable style=\\\"width:100%\\\"\u003e\n                    \u003ctr\u003e\u003ctd\u003e95C\u003c/td\u003e\u003c/tr\u003e\n                    \u003ctr\u003e\u003ctd\u003e57C\u003c/td\u003e\u003c/tr\u003e\n                    \u003ctr\u003e\u003ctd\u003e72C\u003c/td\u003e\u003c/tr\u003e\n      \u003c/table\u003e\"\n    cycles_time = \"\u003ctable style=\\\"width:100%\\\"\u003e\n                    \u003ctr\u003e\u003ctd\u003e30 sec\u003c/td\u003e\u003c/tr\u003e\n                    \u003ctr\u003e\u003ctd\u003e30 sec\u003c/td\u003e\u003c/tr\u003e\n                    \u003ctr\u003e\u003ctd\u003e30 sec\u003c/td\u003e\u003c/tr\u003e\n      \u003c/table\u003e\"\n    t.add_column(\"STEP\", [\"Initial Melt\", \"45 cycles of\", \"Extension\", \"Hold\"])\n    t.add_column(\"TEMP\", [\"95C\", cycles_temp, \"72C\", \"4C\"])\n    t.add_column(\"TIME\", [\"4 min\", cycles_time, \"7 min\", \"forever\"])\n    \n    \n    show do\n        title \"Run PCR\"\n        check \"Talk to your assigner which thermocycler to use\"\n        check \"Close all the lids of the pipette tip boxes and pre-PCR rack\"\n        check \"Take only the PCR tubes (BA1 and BA2) with you\"\n        check \"Place the PCR samples in the assigned thermocycler, close, and tighten the lid\"\n        check \"Select the program named #{PCR_CYCLE} under OS\"\n        check \"Hit #{\"Run\".quote} and #{\"OK to 50uL\".quote}\"\n        table t\n    end\n    \n    operations.each do |op|\n      op.output(OUTPUT).item.move THERMOCYCLER\n    end\n\n    # END OF POST_PCR PCR REACTION...\n  end\n\n  def cleanup myops\n\n    items = [INPUT].map {|x| myops.map {|op| op.input(x)}}.flatten.uniq\n    item_refs = [INPUT].map {|x| myops.map {|op| op.input_ref(x)}}.flatten.uniq\n    temp_items = [\"diluent A\"].map {|x| myops.map {|op| op.ref(x)}}.flatten.uniq\n\n    all_refs = temp_items + item_refs\n\n    show do\n      title \"Throw items into the #{WASTE_PRE}\"\n\n      note \"Throw the following items into the #{WASTE_PRE}\"\n      t = Table.new\n      t.add_column(\"Tube\".bold, all_refs)\n      table t\n    end\n    # clean_area AREA\n  end\n\n  def conclusion myops\n    show do\n      title \"Thank you!\"\n      warning \"\u003ch2\u003eYou must click #{\"OK\".quote.bold} to complete the protocol\u003c/h2\u003e\"\n      check \" After clicking #{\"OK\".quote.bold}, discard your gloves and wash your hands with soap. \"\n      note \"You may start the next protocol in 2 hours.\"\n    end\n  end\n\nend # Class","precondition":"eval Library.find_by_name(\"OLAScheduling\").code(\"source\").content\nextend OLAScheduling\n\ndef precondition(op)\n  schedule_same_kit_ops(op)\n  true\nend","cost_model":"def cost(op)\n  { labor: 7.5, materials: 0 }\nend","documentation":"Generate PCR products from cell lysate which will be used later to detect HIV mutations.","test":"","timing":null}},{"sample_types":[{"id":1,"name":"OLASimple Sample","description":"Patient sample and OLA kit","created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","field_types":[{"id":1,"parent_id":1,"name":"Patient ID","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":2,"parent_id":1,"name":"Secondary Patient ID","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]}]}],"object_types":[{"id":4,"name":"OLA Ligation Stripwell","description":"OLA Ligation Stripwell","min":0,"max":1,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","unit":"Well","cost":0.01,"release_method":"return","release_description":"","sample_type_id":null,"image":null,"prefix":"","rows":1,"columns":12,"sample_type_name":null},{"id":6,"name":"OLA Detection Strips","description":"OLA Detection STrips","min":0,"max":1,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","unit":"strip","cost":0.01,"release_method":"return","release_description":"","sample_type_id":null,"image":null,"prefix":"","rows":1,"columns":12,"sample_type_name":null}],"operation_type":{"name":"OLASimple Paper Detection","category":"OLASimple","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Ligation Product","sample_types":["OLASimple Sample"],"object_types":["OLA Ligation Stripwell"],"part":false,"array":false,"routing":"LP","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"Detection Strip","sample_types":["OLASimple Sample"],"object_types":["OLA Detection Strips"],"part":false,"array":false,"routing":"LP","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"##########################################\n#\n#\n# OLASimple Detection\n# author: Justin Vrana\n# date: March 2018\n#\n#\n##########################################\n\nneeds \"OLASimple/OLAConstants\"\nneeds \"OLASimple/OLALib\"\nneeds \"OLASimple/OLAGraphics\"\nneeds \"OLASimple/JobComments\"\n\nclass Protocol\n  include OLAConstants\n  include OLALib\n  include OLAGraphics\n  include JobComments\n\n#   ##########################################\n#   # INPUT/OUTPUT\n#   ##########################################\n#   F\n  INPUT = \"Ligation Product\"\n  OUTPUT = \"Detection Strip\"\n  PACK = \"Detection Pack\"\n  A = \"Diluent A\"\n  G = \"Gold Mix\"\n  S = \"Stop Mix\"\n\n#   ##########################################\n#   # TERMINOLOGY\n#   ##########################################\n\n#   ##########################################\n#   # Protocol Specifics\n#   ##########################################\n  AREA = POST_PCR\n  NUM_SUB_PACKAGES = 4\n\n#   # 6 codons,\n#   # GOLD_VOLUME = 600\n#   # STOP_VOLUME = 36\n#   # STOP_TO_SAMPLE_VOLUME = 2.4\n#   # SAMPLE_TO_STRIP_VOLUME = 24\n#   # GOLD_TO_STRIP_VOLUME = 40\n\n#   # VOLUMES WILL CHANGES FOR 6 codons!!!!\n  CENTRIFUGE_TIME = \"5 seconds\" # time to pulse centrifuge to pull down dried powder\n  VORTEX_TIME = \"5 seconds\" # time to pulse vortex to mix\n  TUBE_CAP_WARNING = \"Check to make sure tube caps are completely closed.\"\n  PACK_HASH = DETECTION_UNIT\n  STOP_VOLUME = PACK_HASH[\"Stop Rehydration Volume\"]\n  GOLD_VOLUME = PACK_HASH[\"Gold Rehydration Volume\"]\n  STOP_TO_SAMPLE_VOLUME = PACK_HASH[\"Stop to Sample Volume\"]  # volume of competitive oligos to add to sample\n  SAMPLE_TO_STRIP_VOLUME = PACK_HASH[\"Sample to Strip Volume\"] # volume of sample to add to the strips\n  GOLD_TO_STRIP_VOLUME = PACK_HASH[\"Gold to Strip Volume\"]\n  PREV_COMPONENTS = PACK_HASH[\"Components\"][\"strips\"]\n  MUTATION_LABELS = PACK_HASH[\"Mutation Labels\"]\n  \n  PREV_UNIT = \"C\"\n  MATERIALS =  [\n      \"P1000 pipette and filtered tips\",\n      \"P200 pipette and filtered tips\",\n      \"P20 pipette and filtered tips\",\n      \"a spray bottle of 10% v/v bleach\",\n      \"a spray bottle of 70% v/v ethanol\",\n      \"a timer\",\n      \"nitrile gloves\"\n  ]\n  \n  POSITIVE = \"positive\"\n  NEGATIVE = \"negative\"\n  DEBUG_UPLOAD_ID = 3\n\n##########################################\n# ##\n# Input Restrictions:\n# Input needs a kit, unit, components,\n# and sample data associations to work properly\n##########################################\n\n  def main\n    operations.each do |op|\n      op.temporary[:pack_hash] = PACK_HASH\n    end\n    save_user operations\n    operations.running.retrieve interactive: false\n    debug_setup operations\n    save_temporary_input_values(operations, INPUT)\n    save_temporary_output_values(operations)\n    introduction operations.running\n    area_preparation POST_PCR, MATERIALS, PRE_PCR\n    get_detection_packages operations.running\n    open_detection_packages operations.running\n    rehydrate_stop_solution sorted_ops.running\n    wait_for_pcr sorted_ops.running\n    stop_ligation_product sorted_ops.running\n    # short_timer\n    rehydrate_gold_solution sorted_ops.running\n    display_detection_strip_diagram\n    add_ligation_product_to_strips sorted_ops.running\n    add_gold_solution sorted_ops.running\n    read_from_scanner sorted_ops.running\n    \n    analysis operations.running \n    \n    cleanup sorted_ops\n    conclusion sorted_ops\n    accept_comments\n    return {\"Ok\" =\u003e 1}\n  end\n\n  def sorted_ops\n    operations.sort_by {|op| op.output_ref(OUTPUT)}.extend(OperationList)\n  end\n\n  def save_user ops\n    ops.each do |op|\n      username = get_technician_name(self.jid)\n      op.associate(:technician, username)\n    end\n  end\n\n  def debug_setup ops\n    # make an alias for the inputs\n    if debug\n      ops.each do |op|\n        kit_num = rand(1..60)\n        INPUT\n        PREV_UNIT\n        PREV_COMPONENTS\n        make_alias(op.input(INPUT).item, kit_num, PREV_UNIT, PREV_COMPONENTS, 1)\n        # op.input(PACK).item.associate(KIT_KEY, kit_num)\n      end\n\n      if ops.length \u003e= 2\n        i = ops[-1].input(INPUT).item\n        alias_array = get_alias_array(i)\n        alias_array[3] = if (alias_array[3] == 1) then 2 else 1 end\n        make_alias(ops[0].input(INPUT).item, *alias_array)\n\n        # kit_num = ops[-1].input(PACK).item.get(KIT_KEY)\n        # ops[0].input(PACK).item.associate(KIT_KEY, kit_num)\n      end\n    end\n  end\n\n  def run_checks myops\n    if operations.running.empty?\n      show do\n        title \"All operations have errored\"\n        note \"Contact #{SUPERVISOR}\"\n        operations.each do |op|\n          note \"#{op.errors.map {|k, v| [k, v]}}\"\n        end\n      end\n      return {}\n    end\n  end\n\n  def introduction myops\n    username = get_technician_name(self.jid).color(\"darkblue\")\n    show do\n      title \"Welcome #{username} to OLASimple Paper Detection procotol\"\n      note \"In this protocol you will be adding samples from the ligation protocol onto paper detection strips. \" \\\n            \"You will then scan an image of the strips and upload the image. The strips will detect whether the sample has drug resistance mutations.\"\n      check \"Put on gloves.\"      \n      note \"Click \\\"OK\\\" to start the protocol.\"\n    end\n  end\n\n  def get_detection_packages(myops)\n    gops = group_packages(myops)\n    show do\n      title \"Get #{DET_PKG_NAME.pluralize(gops.length)} from the #{FRIDGE_POST}\"\n      gops.each do |unit, ops|\n        check \"package #{unit.bold}\"\n      end\n      check \"Place #{pluralizer('package', gops.length)} on the bench in the #{AREA.bold} area.\"\n    end\n  end\n\n  def open_detection_packages(myops)\n    grouped_by_unit = myops.running.group_by {|op| op.temporary[:output_kit_and_unit]}\n    grouped_by_unit.each do |unit, ops|\n      ops.each do |op|\n        op.make_collection_and_alias(OUTPUT, \"strips\", INPUT)\n      end\n\n      ops.each do |op|\n        op.temporary[:label_string] = \"#{op.output_refs(OUTPUT)[0]} through #{op.output_refs(OUTPUT)[-1]}\"\n      end\n\n      #ljklakjdlkaj\n      #Ljlkj\n\n      tokens = ops.first.output_tokens(OUTPUT)\n      num_samples = ops.first.temporary[:pack_hash][NUM_SAMPLES_FIELD_VALUE]\n\n      grid = SVGGrid.new(num_samples, num_samples, 50, 50)\n      ops.each_with_index do |op, i|\n        tokens = op.output_tokens(OUTPUT)\n        grid.add(display_strip_panel(*tokens, COLORS).scale!(0.5), i, i)\n      end\n\n      diluentATube = self.make_tube(closedtube, \"Diluent A\", ops.first.tube_label(\"diluent A\"), \"medium\", true).scale!(0.75)\n      stopTube = self.make_tube(closedtube, \"Stop mix\", ops.first.tube_label(\"stop\"), \"powder\", true).scale!(0.75)\n      goldTube = self.make_tube(closedtube, \"Gold mix\", ops.first.tube_label(\"gold\"), \"powder\", true, fluidclass: \"pinkfluid\").scale!(0.75)\n      diluentATube.translate!(50, 75)\n      goldTube.align_with(diluentATube, 'top-right').translate!(50)\n      stopTube.align_with(goldTube, 'top-right').translate!(50)\n      img = SVGElement.new(children: [grid, diluentATube, goldTube, stopTube], boundx: 500, boundy: 220)\n      img\n\n      show_open_package(unit, \"\", NUM_SUB_PACKAGES) do\n        note \"Check that there are the following tubes and #{STRIPS}:\"\n        note display_svg(img, 1.0)\n      end\n    end\n\n  end\n\n  def rehydrate_stop_solution myops\n    gops = group_packages(myops)\n    gops.each do |unit, ops|\n      from = ops.first.ref(\"diluent A\")\n      to = ops.first.ref(\"stop\")\n      show do\n        raw transfer_title_proc(STOP_VOLUME, from, to)\n        check \"Centrifuge tube #{to} for 5 seconds to pull down powder.\"\n        check \"Set a #{P200_POST} pipette to [0 3 6]. Add #{STOP_VOLUME}uL from #{from.bold} into tube #{to.bold}\"\n        tubeA = make_tube(opentube, DILUENT_A, ops.first.tube_label(\"diluent A\"), \"medium\")\n        tubeS = make_tube(opentube, STOP_MIX, ops.first.tube_label(\"stop\"), \"powder\")\n        img = make_transfer(tubeA, tubeS, 200, \"#{STOP_VOLUME}uL\", \"(#{P200_POST} pipette)\")\n        img.translate!(20)\n        note display_svg(img, 0.75)\n      end\n\n      vortex_and_centrifuge_helper(\"tube\",\n                                   [to],\n                                   VORTEX_TIME, CENTRIFUGE_TIME,\n                                   \"to mix.\", \"to pull down liquid\", AREA, mynote = nil)\n    end\n  end\n\n  def wait_for_pcr myops\n    show do\n      title \"Wait for thermocycler to finish\"\n\n      note \"The thermocycler containing the #{LIGATION_SAMPLE.pluralize(5)} needs to complete before continuing\"\n      check \"Check the #{THERMOCYCLER} to see if the samples are done.\"\n      bullet \"If the cycle is at \\\"hold at 4C\\\" then it is done. If it is done, hit CANCEL followed by YES. If not, continue waiting.\"\n      note \"Else, if your ligation sample has been stored, retrieve from M20, 4th shelf down, green box.\"\n      warning \"Do not proceed until the #{THERMOCYCLER} is finished.\"\n    end\n  end\n\n  def stop_ligation_product myops\n    gops = myops.group_by { |op| op.temporary[:output_kit_and_unit] }\n    num_tubes = myops.inject(0) { |sum, op| sum + op.output_refs(OUTPUT).length }\n    # ordered_ops = gops.map {|unit, ops| ops}.flatten.extend(OperationList) # organize by unit\n    show do\n      title \"Take #{pluralizer(\"sample\", num_tubes)} from the #{THERMOCYCLER} and place on rack in #{AREA.bold} area\"\n      check \"Centrifuge for 5 seconds to pull down liquid\"\n      check \"Place on rack in post-PCR area\"\n\n      gops.each do |unit, ops|\n        ops.each do |op|\n          note display_svg(display_ligation_tubes(*op.input_tokens(INPUT), COLORS), 0.75)\n        end\n      end\n    end\n\n    gops.each do |unit, ops|\n      from = ops.first.ref(\"stop\")\n      ops.each do |op|\n        to_labels = op.input_refs(INPUT)\n        show do\n          # title \"Get ready to add #{STOP_MIX} to #{LIGATION_SAMPLE.pluralize(MUTATIONS.length)} for #{unit}\"\n          title \"Position #{STOP_MIX} #{from.bold} and colored tubes #{op.input_refs(INPUT)[0].bold} to #{op.input_refs(INPUT)[-1].bold} in front of you.\"\n          note \"In the next steps you will add #{STOP_MIX} to #{pluralizer(\"tube\", PREV_COMPONENTS.length)}\"\n          tube = closedtube.scale(0.75)\n          tube.translate!(0, -50)\n          tube = tube.g\n          tube.g.boundx = 0\n          labeled_tube = make_tube(closedtube, STOP_MIX, op.tube_label(\"stop\"), \"medium\", true)\n          ligation_tubes = display_ligation_tubes(*op.input_tokens(INPUT), COLORS)\n          ligation_tubes.align!('bottom-left')\n          ligation_tubes.align_with(tube, 'bottom-right')\n          ligation_tubes.translate!(50)\n          image = SVGElement.new(children: [labeled_tube, ligation_tubes], boundx: 600, boundy: tube.boundy)\n          image.translate!(50)\n          image.boundy = image.boundy + 50\n          note display_svg(image, 0.75)\n        end\n\n        to_labels.each.with_index do |label, i|\n          show do\n            raw transfer_title_proc(STOP_TO_SAMPLE_VOLUME, from, label)\n            # title \"Add #{STOP_TO_SAMPLE_VOLUME}uL #{STOP_MIX} #{from.bold} to #{LIGATION_SAMPLE} #{label}\"\n            note \"Set a #{P20_POST} pipette to [0 2 4]. Add #{STOP_TO_SAMPLE_VOLUME}uL from #{from.bold} into tube #{label.bold}\"\n            note \"Close tube #{label}.\"\n            note \"Discard pipette tip.\"\n            tubeS = make_tube(opentube, STOP_MIX, op.tube_label(\"stop\"), \"medium\")\n            transfer_image = transfer_to_ligation_tubes_with_highlight(\n                tubeS, i, *op.input_tokens(INPUT), COLORS, STOP_TO_SAMPLE_VOLUME, \"(#{P20_POST} pipette)\")\n            note display_svg(transfer_image, 0.75)\n          end\n        end\n      end\n    end\n    \n    show do\n      title \"Vortex and centrifuge all 12 tubes for 5 seconds.\"\n      check \"Vortex for 5 seconds.\"\n      check \"Centrifuge for 5 seconds.\"\n      note \"This step is important to avoid FALSE POSITIVE.\"\n    end\n\n    t = Table.new()\n    t.add_column(\"STEP\", [\"Initial Melt\", \"Annealing\"])\n    t.add_column(\"TEMP\", [\"95C\", \"37C\"])\n    t.add_column(\"TIME\", [\"30s\", \"4 min\"])\n    add_to_thermocycler(\"tube\", myops.length * PREV_COMPONENTS.length, STOP_CYCLE, t, \"Stop Cycle\")\n  end\n\n  def short_timer\n    show do\n      title \"Set timer for 6 minutes\"\n      check \"Set a timer for 6 minutes. This will notify you when the thermocycler is done.\"\n      timer initialize: {minute: 6}\n      check \"Click the \\\"\u003cb\u003eplay\u003c/b\u003e\\\" button on the left. Proceed to next step now.\"\n    end\n  end\n\n  def display_detection_strip_diagram\n    show do\n      title \"Review detection #{STRIP} diagram\"\n      note \"In the next steps you will be adding ligation mixtures followed by the gold solutions to the detection strips.\"\n      note \"You will pipette into the \u003cb\u003ePort\u003c/b\u003e. After pipetting, you should see the \u003cb\u003eReading Window\u003c/b\u003e become wet after a few minutes.\"\n      warning \"Do not add liquid directly to the \u003cb\u003eReading Window\u003c/b\u003e\"\n      note display_svg(detection_strip_diagram, 0.75)\n    end\n  end\n\n  def add_ligation_product_to_strips myops\n    gops = group_packages(myops)\n\n    show do\n      title \"Wait for stop cycle to finish (5 minutes).\"\n      check \"Wait for the #{THERMOCYCLER} containing your samples to finish. \"\n      bullet \"If the #{THERMOCYCLER} beeps, it is done. If not, continue waiting.\"\n      check \"Once the #{THERMOCYCLER} finishes, IMMEDIATELY continue to the next step.\"\n      check \"Take all #{pluralizer(\"sample\", myops.length * PREV_COMPONENTS.length)} from the #{THERMOCYCLER}.\"\n      check \"Vortex #{\"sample\".pluralize(PREV_COMPONENTS.length)} for 5 seconds to mix.\"\n      check \"Centrifuge #{\"sample\".pluralize(PREV_COMPONENTS.length)} for 5 seconds to pull down liquid\"\n      check \"Place on rack in the #{POST_PCR.bold} area.\"\n    end\n\n    timer_set = false\n    gops.each do |unit, ops|\n      ops.each do |op|\n        kit = op.temporary[:output_kit]\n        sample = op.temporary[:output_sample]\n        panel_unit = op.temporary[:output_unit]\n        tube_unit = op.temporary[:input_unit]\n        show do\n          title \"Arrange #{STRIPS} and tubes\" # for sample 1?\n          note \"Place the detection #{STRIPS} and #{LIGATION_SAMPLE.pluralize(PREV_COMPONENTS.length)} as shown in the picture:\"\n          note display_svg(display_panel_and_tubes(kit, panel_unit, tube_unit, PREV_COMPONENTS, sample, COLORS).translate!(50), 0.6)\n        end\n\n        show do\n          title \"For each colored tube, add #{SAMPLE_TO_STRIP_VOLUME}uL of #{LIGATION_SAMPLE} to the sample port of each #{STRIP}.\"\n          warning \"\u003ch2\u003eSet a 5 minute timer after adding ligation sample to \u003cb\u003eFIRST A1\u003c/b\u003e strip at the SAMPLE PORT.\u003c/h2\u003e\" unless timer_set\n          warning \"\u003ch2\u003eAdd the rest of ligation samples to the rest of strips and then immediately click OK\u003c/h2\u003e\"\n          timer_set = true\n          #   check \"Set a 5 minute timer\" unless set_timer\n          check \"Set a #{P200_POST} pipette to [0 2 4]. Add #{SAMPLE_TO_STRIP_VOLUME}uL of \u003cb\u003eeach\u003c/b\u003e #{LIGATION_SAMPLE} to the corresponding #{STRIP}.\"\n          note \"Match the sample tube color with the #{STRIP} color. For example, match #{op.input_refs(INPUT)[0].bold} to #{op.output_refs(OUTPUT)[0].bold}\"\n        #   note \"After adding the first sample, set the timer for 5 minutes\"\n          warning \"Dispose of pipette tip and close tube after each strip.\"\n          tubes = display_ligation_tubes(*op.input_tokens(INPUT), COLORS, (0..PREV_COMPONENTS.length - 1).to_a, [], 90)\n          panel = display_strip_panel(*op.output_tokens(OUTPUT), COLORS)\n          tubes.align_with(panel, 'center-bottom')\n          tubes.align!('center-top')\n          tubes.translate!(50, -50)\n          img = SVGElement.new(children: [panel, tubes], boundy: 330, boundx: panel.boundx)\n          note display_svg(img, 0.6)\n        end\n      end\n    end\n    show do\n          title \"Check to see if strips are wetting\"\n          note \"You should see the strip become wet in reading window \"\n          note \"If strips are not wetting after 2 minutes, contact #{SUPERVISOR}\"\n          warning \"Do not continue until all strips are fully wet.\"\n     end\n\n  end\n\n  def rehydrate_gold_solution myops\n    gops = group_packages(myops)\n    gops.each do |unit, ops|\n      from = ops.first.ref(\"diluent A\")\n      to = ops.first.ref(\"gold\")\n\n      show do\n        raw transfer_title_proc(GOLD_VOLUME, from, to)\n        # title \"Add #{GOLD_VOLUME}uL of #{DILUENT_A} #{from.bold} to #{GOLD_MIX} #{to.bold}\"\n        raw centrifuge_proc(GOLD_MIX, [to], CENTRIFUGE_TIME, \"to pull down dried powder.\", AREA)\n        note \"Set a #{P1000_POST} pipette to [ 0 6 0]. Add #{GOLD_VOLUME}uL from #{from.bold} into tube #{to.bold}.\"\n        raw vortex_proc(GOLD_MIX, [to], \"10 seconds\", \"to mix well.\")\n        warning \"Make sure #{GOLD_MIX} is fully dissolved.\"\n        warning \"Do not centrifuge #{to.bold} after vortexing.\"\n        tubeA = make_tube(opentube, DILUENT_A, ops.first.tube_label(\"diluent A\"), \"medium\")\n        tubeG = make_tube(opentube, GOLD_MIX, ops.first.tube_label(\"gold\"), \"powder\", fluidclass: \"pinkfluid\")\n        img = make_transfer(tubeA, tubeG, 200, \"#{GOLD_VOLUME}uL\", \"(#{P1000_POST} pipette)\")\n        img.translate!(20)\n        note display_svg(img, 0.75)\n      end\n    end\n  end\n\n  def add_gold_solution myops\n    gops = group_packages(myops)\n    set_timer = false\n\n    show do\n      title \"Wait until 5 minute timer ends\"\n      warning \"Do not proceed before 5 minute timer is up.\"\n      note \"The strips need a chance to become fully wet.\"\n    end\n\n    gops.each do |unit, ops|\n        show do\n            title \"Add gold solution to #{pluralizer(STRIP, PREV_COMPONENTS.length * ops.length)}\" \n            warning \"\u003ch2\u003eSet a 10 minute timer after adding gold to \u003cb\u003eFIRST A1\u003c/b\u003e strip at the SAMPLE PORT.\u003c/h2\u003e\"\n            warning \"\u003ch2\u003e Add gold to the rest of strips and then immediately click OK.\"\n            warning \"\u003ch2\u003e DO NOT add gold solution onto the reading window.\"\n            check \"Set a #{P200_POST} pipette to [0 4 0]. Transfer #{GOLD_TO_STRIP_VOLUME}uL of #{GOLD_MIX} #{ops.first.ref(\"gold\").bold} to #{pluralizer(STRIP, PREV_COMPONENTS.length * ops.length)}.\"\n            grid = SVGGrid.new(ops.length,  ops.length, 50, 50)\n            ops.each.with_index do |op, i|\n                _tokens = op.output_tokens(OUTPUT)\n                grid.add(display_strip_panel(*_tokens, COLORS).scale!(0.5), i, i)\n            end\n            tubeG = make_tube(opentube, GOLD_MIX, ops.first.tube_label(\"gold\"), \"medium\", fluidclass: \"pinkfluid\")\n            img = make_transfer(tubeG, grid, 200, \"#{GOLD_TO_STRIP_VOLUME}uL\", \"(each strip)\")\n            img.boundx = 900\n            img.boundy = 400\n            img.translate!(40)\n            note display_svg(img, 0.6)\n        end\n      end\n  end\n\n  def read_from_scanner myops\n    gops = group_packages(myops)\n    show do\n      title \"Bring timer and #{pluralizer(STRIP, myops.length * PREV_COMPONENTS.length)} to the #{PHOTOCOPIER}.\"\n      image \"Actions/OLA/map_Klavins.svg\" if KIT_NAME == \"uw kit\"\n    end\n    \n    show do\n      title \"Wait until 10 minute timer is up\"\n      note \"#{STRIPS.capitalize} need to rest for 10 minutes before taking an image.\"\n      note \"In the meantime, make sure you have access to the #{PHOTOCOPIER}.\"\n      warning \"\u003ch2\u003e Signal can develop more slowly if the room is humid. After the 10-min timer ends, you should see at least two lines on each strip. \u003c/h2\u003e\" \n      warning \"If your signal is hard to see by eyes, give it another 5 minutes before clicking OK.\"\n    end\n\n    # show do\n    #   title \"IMPORTANT NOTE TO JUSTIN\"\n    #   warning \"This protocol should be broken into two since technician will be moving from one computer to the next.\"\n    #   note \"This really depends on whether we want to use the laptop ONLY for detection purposes (I think we should)\"\n    # end\n\n    myops.each do |op|\n      op.temporary[:filename] = \"#{op.output(OUTPUT).item.id}_#{op.temporary[:output_kit]}#{op.temporary[:output_sample]}\"\n    end\n\n    gops.each do |unit, ops|\n      ops.each do |op|\n        labels = op.output_refs(OUTPUT)\n        show do\n          title \"Scan #{STRIPS} \u003cb\u003e#{labels[0]} to #{labels[-1]}\u003c/b\u003e\"\n          check \"Open #{PHOTOCOPIER}\"\n          check \"Place #{STRIPS} face down in the #{PHOTOCOPIER}\"\n          check \"Align colored part of #{STRIPS} with the colored tape on the #{PHOTOCOPIER}\"\n          check \"Close the #{PHOTOCOPIER}\"\n        end\n\n        image_confirmed = false\n\n        5.times.each do |this_try|\n          unless image_confirmed\n            show do\n              title \"Scan the image\"\n              check \"Press the \u003cb\u003e\\\"AUTO SCAN\\\"\u003c/b\u003e button firmly on the side of the #{PHOTOCOPIER} and hold for a few seonds. A new window should pop up, with a green bar indicating scanning in progress.\"\n              check \"Wait for #{PHOTOCOPIER} to complete. This takes about 1 minute.\"\n            end\n\n            rename = \"\u003cmd-button ng-disabled=\\\"true\\\" class=\\\"md-raised\\\"\u003erename\u003c/md-button\u003e\"\n            copy = \"\u003cmd-button ng-disabled=\\\"true\\\" class=\\\"md-raised\\\"\u003ecopy\u003c/md-button\u003e\"\n            paste = \"\u003cmd-button ng-disabled=\\\"true\\\" class=\\\"md-raised\\\"\u003epaste\u003c/md-button\u003e\"\n\n            show do\n              title \"Copy image file name #{op.temporary[:filename].bold}\"\n              note \"1. highlight the file name: #{op.temporary[:filename].bold}\"\n              note \"2. then click #{copy}\"\n              title \"Then rename the new image file to #{op.temporary[:filename].bold}\"\n              note \"1. a new file should appear on the desktop. Minimize this browser and find the new file.\"\n              note \"2. right-click and then click #{rename}\"\n              note \"3. right-click and click #{paste} to rename file.\"\n            end\n\n            show_with_expected_uploads(op, op.temporary[:filename], SCANNED_IMAGE_UPLOAD_KEY) do\n              title \"Upload file \u003cb\u003e#{op.temporary[:filename]}\u003c/b\u003e\"\n              note \"Click the button below to upload file \u003cb\u003e#{op.temporary[:filename]}\u003c/b\u003e\"\n              note \"Navigate to the desktop. Click on file \u003cb\u003e#{op.temporary[:filename]}\u003c/b\u003e\"\n            end\n            \n            if debug # false upload if debug\n                op.temporary[SCANNED_IMAGE_UPLOAD_KEY] = Upload.find(DEBUG_UPLOAD_ID)\n            end\n            \n            confirmed = show do\n              title \"Confirm image labels say #{op.temporary[:label_string].bold}\"\n              select [ \"yes\", \"no\"], var: \"confirmed\", label: \"Do the image labels and your image match?\", default: 0\n              img = display_strip_panel(*op.output_tokens(OUTPUT), COLORS).g\n              img.boundy = 50\n              note display_svg(img, 0.75)\n              raw display_upload(op.temporary[SCANNED_IMAGE_UPLOAD_KEY])\n            end\n\n            image_confirmed = confirmed[:confirmed] == \"yes\"\n\n            unless image_confirmed\n              show do\n                title \"You selected that the images don't match!\"\n                note \"You will now be asked to scan and upload the strip again.\"\n              end\n            end\n          end\n        end\n\n        op.associate(SCANNED_IMAGE_UPLOAD_ID_KEY, op.temporary[SCANNED_IMAGE_UPLOAD_KEY].id)\n        op.output(OUTPUT).item.associate(SCANNED_IMAGE_UPLOAD_ID_KEY, op.temporary[SCANNED_IMAGE_UPLOAD_KEY].id)\n      end\n    end\n  end\n\n  def cleanup myops\n    def discard_refs_from_op(op)\n      refs = []\n      refs.push(\"Diluent A \" + op.ref(\"diluent A\").bold)\n      refs.push(\"Gold Mix \" + op.ref(\"gold\").bold)\n      refs.push(\"Stop Mix \" + op.ref(\"stop\").bold)\n      unless KIT_NAME == \"uw kit\"\n        refs.push(\"Samples #{op.input_refs(INPUT).join(', ').bold}\")\n      end\n      refs\n    end\n\n    all_refs = myops.map {|op| discard_refs_from_op(op)}.flatten.uniq\n\n    show do\n      title \"Throw items into the #{WASTE_POST}\"\n\n      note \"Throw the following items into the #{WASTE_POST} in the #{AREA.bold} area:\"\n      t = Table.new\n      t.add_column(\"Item to throw away\", all_refs)\n      table t\n    end\n\n    show do\n      disinfectant = \"10% bleach\"\n      title \"Wipe down #{AREA.bold} with #{disinfectant.bold}.\"\n      note \"Now you will wipe down your #{BENCH_POST} and equipment with #{disinfectant.bold}.\"\n      check \"Spray #{disinfectant.bold} onto a #{WIPE_POST} and clean off pipettes and pipette tip boxes.\"\n      check \"Spray a small amount of #{disinfectant.bold} on the bench surface. Clean bench with #{WIPE_POST}.\"\n      # check \"Spray some #{disinfectant.bold} on a #{WIPE}, gently wipe down keyboard and mouse of this computer/tablet.\"\n      warning \"Do not spray #{disinfectant.bold} onto tablet or computer!\"\n      check \"Finally, spray outside of gloves with #{disinfectant.bold}.\"\n    end\n\n    show do\n      disinfectant = \"70% ethanol\"\n      title \"Wipe down #{AREA.bold} with #{disinfectant.bold}.\"\n      note \"Now you will wipe down your #{BENCH_POST} and equipment with #{disinfectant.bold}.\"\n      check \"Spray #{disinfectant.bold} onto a #{WIPE_POST} and clean off pipettes and pipette tip boxes.\"\n      check \"Spray a small amount of #{disinfectant.bold} on the bench surface. Clean bench with #{WIPE_POST}.\"\n    #   check \"Spray a #{\"small\".bold} amount of #{disinfectant.bold} on a #{WIPE}. Gently wipe down keyboard and mouse of this computer/tablet.\"\n      warning \"Do not spray #{disinfectant.bold} onto tablet or computer!\"\n      check \"Finally, dispose of gloves in garbage bin.\"\n    end\n  end\n\n  def filename(op)\n    item_id = op.output(OUTPUT).item.id\n    labels = op.output_refs(OUTPUT)\n    \"#{labels[0]}_#{labels[-1]}_#{item_id}\"\n  end\n\n  def conclusion myops\n    show do\n      title \"Thank you!\"\n      warning \"\u003ch2\u003eYou must click #{\"OK\".quote.bold} to complete the protocol\u003c/h2\u003e\"\n      note \"Thank you for all your hard work.\"\n    end\n  end\n  \n  def analysis ops\n    band_choices = {\n        \"M\": {bands: [mut_band], description: \"-CTRL -WT +MUT\"},\n        \"N\": {bands: [control_band, wt_band, mut_band], description: \"+CTRL +WT +MUT\"},\n        \"O\": {bands: [control_band, mut_band], description: \"+CTRL -WT +MUT\"},\n        \"P\": {bands: [control_band, wt_band], description: \"+CTRL +WT -MUT\"},\n        \"Q\": {bands: [control_band], description: \"+CTRL -WT -MUT\"},\n        \"R\": {bands: [], description: \"-CTRL -WT -MUT\"}\n    }\n\n    categories = {\n        \"M\": POSITIVE,\n        \"N\": POSITIVE,\n        \"O\": POSITIVE,\n        \"P\": NEGATIVE,\n        \"Q\": \"ligation failure\",\n        \"R\": \"detection failure\"\n    }\n    \n    run_image_analysis ops.running, band_choices, categories\n    show_calls ops.running, band_choices\n    show_summary ops.running\n  end\n  \n  def run_image_analysis ops, band_choices, category_hash\n    ops.each do |op|\n      image_result = nil\n      5.times.each do |i|\n          break if image_result\n          upload = op.temporary[SCANNED_IMAGE_UPLOAD_KEY]\n          image_result = make_calls_from_image(upload)\n      end\n      \n      if image_result.nil?\n        op.error(:image_result_failed, \"Image processing has failed. Check that the OLA IP service is running and connected correctly, and that the file is in a normal image format.\") \n        next\n      end\n        \n      this_kit = op.temporary[:output_kit]\n      this_unit = op.temporary[:output_unit]\n      this_sample = op.temporary[:output_sample]\n      \n      raise \"scanned image had less strips than expected!\" if PREV_COMPONENTS.size \u003e image_result.size\n      raise \"scanned image had more strips than expected!\" if PREV_COMPONENTS.size \u003c image_result.size\n      PREV_COMPONENTS.each.with_index do |this_component, i|\n        alias_label = op.output_refs(OUTPUT)[i]\n        the_choice = image_result[i]\n        op.output(OUTPUT).item.associate(make_call_key(alias_label), the_choice)\n        op.output(OUTPUT).item.associate(make_call_category_key(alias_label), category_hash[the_choice.to_sym])\n        op.associate(make_call_key(alias_label), the_choice)\n        op.associate(make_call_category_key(alias_label), category_hash[the_choice.to_sym])\n      end\n    end\n  end\n\n  def make_call_key alias_label\n    \"#{alias_label}_call\".to_sym\n  end\n\n  def make_call_description_key alias_label\n    \"#{alias_label}_call_description\".to_sym\n  end\n\n  def make_call_category_key alias_label\n    \"#{alias_label}_call_category\".to_sym\n  end\n  \n  def show_calls myops, band_choices\n    myops.each do |op|\n      kit_summary = {}\n\n      this_kit = op.temporary[:input_kit]\n      this_item = op.output(OUTPUT).item\n      this_unit = op.temporary[:output_unit]\n      this_sample = op.temporary[:output_sample]\n\n      grid = SVGGrid.new(MUTATION_LABELS.length, 1, 90, 10)\n      categories = []\n      \n      PREV_COMPONENTS.each.with_index do |this_component, i|\n        alias_label = op.output_refs(OUTPUT)[i]\n        strip_label = self.tube_label(this_kit, this_unit, this_component, this_sample)\n        strip = make_strip(strip_label, COLORS[i] + \"strip\")\n        band_choice = this_item.get(make_call_key(alias_label))\n        codon_label = label(MUTATION_LABELS[i], \"font-size\".to_sym =\u003e 25)\n        codon_label.align_with(strip, 'center-bottom')\n        codon_label.align!('center-top').translate!(0, 30)\n        category = this_item.get(make_call_category_key(alias_label))\n        kit_summary[MUTATION_LABELS[i]] = {:alias =\u003e alias_label, :category =\u003e category.to_s, :call =\u003e band_choice.to_s}\n        tokens = category.split(' ')\n        tokens.push(\"\") if tokens.length == 1\n        category_label = two_labels(*tokens)\n        category_label.scale!(0.75)\n        category_label.align!('center-top')\n        category_label.align_with(codon_label, 'center-bottom')\n        category_label.translate!(0, 10)\n        bands = band_choices[band_choice.to_sym][:bands]\n        grid.add(strip, i, 0)\n        grid.add(codon_label, i, 0)\n        grid.add(category_label, i, 0)\n        bands.each do |band|\n          grid.add(band, i, 0)\n        end\n      end\n\n      op.associate(:results, kit_summary)\n      op.output(OUTPUT).item.associate(:results, kit_summary)\n      op.temporary[:results] = kit_summary\n\n      img = SVGElement.new(children: [grid], boundx: 600, boundy: 350)\n      img.translate!(15)\n      show do\n        refs = op.output_refs(OUTPUT)\n        title \"Here is the summary of your results for \u003cb\u003e#{refs[0]}-#{refs[-1]}\u003c/b\u003e\"\n        note display_svg(img)\n      end\n    end\n  end\n\n  def show_summary ops\n    ops.each do |op|\n      hits = op.temporary[:results].select {|k, v| v == POSITIVE}\n    end\n    show do\n      title \"Sample summary\"\n      note \"You analyzed #{ops.length} #{\"kit\".pluralize(ops.length)}. Below is the summarized data.\"\n\n      results_hash = {}\n      kits = ops.map {|op| op.output(OUTPUT).item.get(KIT_KEY)}\n      samples = ops.map {|op| op.output(OUTPUT).item.get(SAMPLE_KEY)}\n      t = Table.new\n      t.add_column(\"Kit\", kits)\n      t.add_column(\"Sample\", samples)\n      MUTATION_LABELS.each do |label|\n        col = ops.map {|op| op.temporary[:results][label][:category]}\n        t.add_column(label, col)\n        results_hash[label] = col\n      end\n      results_hash[\"kits\"] = kits\n      results_hash[\"samples\"] = samples\n      table t\n    end\n  end\nend","precondition":"eval Library.find_by_name(\"OLAScheduling\").code(\"source\").content\nextend OLAScheduling\n\nBATCH_SIZE = 2\ndef precondition(op)\n  schedule_same_kit_ops(op)\n  true\nend","cost_model":"def cost(op)\n  { labor: 12.5, materials: 0 }\nend","documentation":"Samples from the OLASimple ligation protocol are added onto paper detection strips. Then, an an image of the strips is scanned and uploaded. The strips will detect whether the sample has drug resistance mutations, and the protocol will extract this information using computer vision.\n\nThis protocol relies on an image processing service available at the URL given in the OLAConstants library as `OLA_IP_API_URL`.","test":"","timing":null}},{"sample_types":[{"id":1,"name":"OLASimple Sample","description":"Patient sample and OLA kit","created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","field_types":[{"id":1,"parent_id":1,"name":"Patient ID","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":2,"parent_id":1,"name":"Secondary Patient ID","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]}]}],"object_types":[{"id":5,"name":"OLA viral RNA","description":"RNA extracted from patient plasma","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","unit":"OLASimple Sample","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":null,"prefix":"","rows":null,"columns":null,"sample_type_name":"OLASimple Sample"},{"id":7,"name":"OLA plasma","description":"Patient plasma in tube identified as SXXX. Starting point for OLA Simple RT-PCR workflow.","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-05-27T15:06:38.000-07:00","updated_at":"2020-05-27T15:06:38.000-07:00","unit":"OLASimple Sample","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":null,"prefix":"","rows":null,"columns":null,"sample_type_name":"OLASimple Sample"}],"operation_type":{"name":"OLASimple RNA Extraction","category":"OLASimple","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"output","name":"Viral RNA","sample_types":["OLASimple Sample"],"object_types":["OLA viral RNA"],"part":false,"array":false,"routing":"C","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"input","name":"Plasma","sample_types":["OLASimple Sample"],"object_types":["OLA plasma"],"part":false,"array":false,"routing":"C","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"needs \"OLASimple/OLAConstants\"\nneeds \"OLASimple/OLALib\"\nneeds \"OLASimple/OLAGraphics\"\nneeds \"OLASimple/JobComments\"\nneeds \"OLASimple/OLAKitIDs\"\n\nclass Protocol\n  include OLAConstants\n  include OLALib\n  include OLAGraphics\n  include JobComments\n  include OLAKitIDs\n\n  ##########################################\n  # INPUT/OUTPUT\n  ##########################################\n\n  INPUT = \"Plasma\"\n  OUTPUT = \"Viral RNA\"\n\n  ##########################################\n  # COMPONENTS\n  ##########################################\n\n  AREA = PRE_PCR\n  BSC = \"BSC\"\n  ETHANOL = \"molecular grade ethanol\"\n  GuSCN_WASTE = \"GuSCN waste container\"\n  \n  \n  PACK_HASH = {\n    \"Unit Name\" =\u003e \"E\",\n    \"Components\" =\u003e {\n        \"sample tube\" =\u003e \"2\",\n        \"diluent A\" =\u003e \"1\"\n    },\n    \"Number of Samples\" =\u003e 2,\n  }\n  \n  THIS_UNIT = \"E\"\n  INCOMING_SAMPLE = \"S\"\n  DTT = \"E0\"\n  LYSIS_BUFFER = \"E1\"\n  WASH1 = \"E2\"\n  WASH2 = \"E3\"\n  SA_WATER= \"E4\"\n  SAMPLE_COLUMN = \"E5\"\n  RNA_EXTRACT = \"E6\"\n  \n  KIT_SVGs = {\n    INCOMING_SAMPLE =\u003e :roundedtube,\n    DTT =\u003e :roundedtube,\n    LYSIS_BUFFER =\u003e :roundedtube,\n    SA_WATER =\u003e :roundedtube,\n    WASH1 =\u003e :screwbottle,\n    WASH2 =\u003e :screwbottle,\n    SAMPLE_COLUMN =\u003e :samplecolumn,\n    RNA_EXTRACT =\u003e :tube,\n  }\n  \n  SHARED_COMPONENTS = [DTT, WASH1, WASH2, SA_WATER]\n  PER_SAMPLE_COMPONENTS = [LYSIS_BUFFER, SAMPLE_COLUMN, RNA_EXTRACT]\n  OUTPUT_COMPONENT = \"6\"\n  \n\n  CENTRIFUGE_TIME = \"1 minute\"\n\n  def main\n\n    this_package = prepare_protocol_operations\n\n    introduction\n    record_technician_id\n    safety_warning\n    required_equipment\n    \n    retrieve_inputs\n    kit_num = extract_kit_number(this_package)\n    sample_validation_with_multiple_tries(kit_num)\n    \n    retrieve_and_open_package(this_package)\n    \n    prepare_buffers\n    lyse_samples\n    add_ethanol\n\n    3.times do\n      operations.each { |op| add_sample_to_column(op) }\n      centrifuge_columns(flow_instructions: \"Discard flow through into #{GuSCN_WASTE}\")\n    end\n    change_collection_tubes\n\n    add_wash_1\n    centrifuge_columns(flow_instructions: \"Discard flow through into #{GuSCN_WASTE}\")\n    change_collection_tubes\n    \n    add_wash_2\n    centrifuge_columns(flow_instructions: \"Discard flow through into #{GuSCN_WASTE}\")\n    change_collection_tubes\n\n    transfer_column_to_e6\n    elute\n    incubate(sample_labels.map { |s| \"#{SAMPLE_COLUMN}-#{s}\" }, \"1 minute\")\n    centrifuge_columns(flow_instructions: \"\u003cb\u003eDO NOT DISCARD FLOW THROUGH\u003c/b\u003e\")\n\n    finish_up\n    disinfect\n    store\n    cleanup\n\n    accept_comments\n    return {}\n  end\n\n  # perform initiating steps for operations, \n  # and gather kit package from operations\n  # that will be used for this protocol.\n  # returns kit package if nothing went wrong\n  def prepare_protocol_operations\n    if operations.length \u003e BATCH_SIZE\n      raise \"Batch size \u003e #{BATCH_SIZE} is not supported for this protocol. Please rebatch.\"\n    end\n\n    operations.make.retrieve interactive: false\n    \n    populate_temporary_kit_info_from_input_associations(operations, INPUT)\n    propogate_kit_info_forward(operations, INPUT, OUTPUT)\n    \n    kits = operations.running.group_by { |op| op.temporary[KIT_KEY]}\n    this_package = THIS_UNIT + kits.keys.first\n    if kits.length \u003e 1\n        raise \"More than one kit is not supported by this protocol. Please rebatch.\" \n    end\n    operations.make\n    set_output_components(operations, OUTPUT_COMPONENT, THIS_UNIT)\n\n    this_package\n  end\n\n  def sample_labels\n    operations.map { |op| op.temporary[SAMPLE_KEY] }\n  end\n\n  def save_user ops\n    ops.each do |op|\n      username = get_technician_name(self.jid)\n      op.associate(:technician, username)\n    end\n  end\n\n  def introduction\n    show do\n      title \"Welcome to OLASimple RNA Extraction\"\n      check \"Put on tight gloves. Tight gloves help reduce chances for your gloves to be trapped when closing the tubes which can increase contamination risk.\"\n      note \"In this protocol you will lyse and purify RNA from HIV-infected plasma.\"\n      check \"OLA RNA Extraction is sensitive to contamination. Small contamination from the previously amplified products can cause false positives. Before proceeding, wipe the space and pipettes with 10% bleach (freshly prepared or prepared daily) and 70% ethanol using paper towels.\"\n      note \"RNA is prone to degradation by RNase present in our eyes, skin, and breath. Avoid opening tubes outside the Biosafety Cabinet (BSC).\"\n      note \"Change gloves after touching any common surface (such as a refrigerator door handle) as your gloves now can be contaminated by RNase or other previously amplified products that can cause false positives.\"\n      check \"Before starting this protocol, make sure you have access to molecular grade ethanol (~10 mL). Do not use other grades of ethanol as this will negatively affect the RNA extraction yield.\"\n\n    end\n\n  end\n\n  def safety_warning\n    show do\n      title \"Review the safety warnings\"\n      warning \"You will be working with infectious materials.\"\n      note \"Do \u003cb\u003eALL\u003c/b\u003e work in a biosafety cabinet (#{BSC.bold})\"\n      note \"Always wear a lab coat and gloves for this protocol.\"\n      warning \"Do not mix #{LYSIS_BUFFER} or #{WASH1} with bleach, as this will generate toxic cyanide gas. #{LYSIS_BUFFER} AND #{WASH1} waste must be discarded appropriately based on guidelines for GuSCN handling waste\"\n      check \"Put on a lab coat and \\\"doubled\\\" gloves now.\"\n    end\n  end\n\n  def required_equipment\n    show do\n      title \"Get required equipment\"\n      note \"You will need the following equipment in the #{BSC.bold}\"\n      materials = [\n          \"P1000 pipette and filter tips\",\n          \"P200 pipette and filter tips\",\n          \"P20 pipette and filter tips\",\n          \"Vortex mixer\",\n          \"Cold tube rack\",\n          \"Timer\",\n          \"Bleach in a beaker\",\n          \"70% v/v ethanol\",\n          \"Molecular grade ethanol\"\n      ]\n      materials.each do |m|\n        check m\n      end\n    end\n  end\n  \n  def retrieve_and_open_package(this_package)\n    show do\n      title \"Take package #{this_package.bold} from the #{FRIDGE_PRE} and place on the #{BENCH_PRE} in the #{BSC}\"\n      check \"Grab package\"\n      check \"Remove the \u003cb\u003eoutside layer\u003c/b\u003e of gloves (since you just touched the door knob).\"\n      check \"Put on a new outside layer of gloves.\"\n    end\n    \n    show_open_package(this_package, \"\", 0) do\n      img = kit_image\n      check \"Check that the following are in the pack:\"\n      note display_svg(img, 0.75)\n      note \"Arrange tubes on plastic rack for later use.\"\n    end\n  end\n  \n  def kit_image\n    grid = SVGGrid.new(PER_SAMPLE_COMPONENTS.size + SHARED_COMPONENTS.size, operations.size, 80, 100)\n\n    initial_contents = {\n      INCOMING_SAMPLE =\u003e 'full',\n      DTT =\u003e 'full',\n      LYSIS_BUFFER =\u003e 'full',\n      SA_WATER =\u003e 'full',\n      WASH1 =\u003e 'full',\n      WASH2 =\u003e 'full',\n      SAMPLE_COLUMN =\u003e 'empty',\n      RNA_EXTRACT =\u003e 'empty',\n    }\n    \n    SHARED_COMPONENTS.each_with_index do |component, i|\n      svg = draw_svg(KIT_SVGs[component], svg_label: component, opened: false, contents: initial_contents[component])\n      grid.add(svg, i, 0)\n    end\n\n    operations.each_with_index do |op, i|\n      sample_num = op.temporary[SAMPLE_KEY]\n      PER_SAMPLE_COMPONENTS.each_with_index do |component, j|\n        svg = draw_svg(KIT_SVGs[component], svg_label: \"#{component}\\n#{sample_num}\", opened: false, contents: initial_contents[component])\n        svg.translate!(30 * (i % 2), 0)\n        grid.add(svg, j + SHARED_COMPONENTS.size, i)\n      end\n    end\n    grid.align!('center-left')\n    img = SVGElement.new(children: [grid], boundx: 1000, boundy: 300).translate!(30, 50)\n  end\n  \n  \n  def retrieve_inputs\n    input_samples = sample_labels.map {  |s| \"#{INCOMING_SAMPLE}-#{s}\" }\n    \n    grid = SVGGrid.new(input_samples.size, 1, 80, 100)\n    input_samples.each_with_index do |s,i|\n      svg = draw_svg(KIT_SVGs[INCOMING_SAMPLE], svg_label: s.split('-').join(\"\\n\"), opened: false, contents: 'full')\n      grid.add(svg, i, 0)\n    end\n    \n    img = SVGElement.new(children: [grid], boundx: 1000, boundy: 200).translate!(0, -30)\n    show do\n      title \"Retrieve Samples\"\n      note display_svg(img, 0.75)\n      check \"Take #{input_samples.to_sentence} from #{FRIDGE_PRE}\"\n    end\n  end\n  \n  # helper method for simple transfers in this protocol\n  def transfer_and_vortex(title, from, to, volume_ul, warning: nil, to_contents: 'empty')\n    pipette, extra_note = pipette_decision(volume_ul)\n    \n    from_component, from_sample_num = from.split('-')\n    to_component, to_sample_num = to.split('-')\n    \n    if KIT_SVGs[from_component] \u0026\u0026 KIT_SVGs[to_component]\n      from_label = [from_component, from_sample_num].join(\"\\n\")\n      from_svg = draw_svg(KIT_SVGs[from_component], svg_label: from_label, opened: true, contents: 'full')\n      to_label = [to_component, to_sample_num].join(\"\\n\")\n      to_svg = draw_svg(KIT_SVGs[to_component], svg_label: to_label, opened: true, contents: to_contents)\n      img = make_transfer(from_svg, to_svg, 250, \"#{volume_ul}ul\", \"(#{pipette})\")\n    end\n    \n    show do\n      title title\n      check \"Transfer \u003cb\u003e#{volume_ul}uL\u003c/b\u003e of \u003cb\u003e#{from}\u003c/b\u003e into \u003cb\u003e#{to}\u003c/b\u003e using a #{pipette} pipette.\"\n      note extra_note if extra_note\n      warning warning if warning\n      note display_svg(img, 0.75) if img\n      check 'Discard pipette tip.'\n      check \"Vortex \u003cb\u003e#{to}\u003c/b\u003e for \u003cb\u003e2 seconds, twice\u003c/b\u003e.\"\n      check \"Centrifuge \u003cb\u003e#{to}\u003c/b\u003e for \u003cb\u003e5 seconds\u003c/b\u003e.\"\n    end\n  end\n  \n  def pipette_decision(volume_ul)\n    if volume_ul \u003c= 20\n      return P20_PRE\n    elsif volume_ul \u003c= 200\n      return P200_PRE\n    elsif volume_ul \u003c= 1000\n      return P1000_PRE\n    else\n      factor = volume_ul.fdiv(1000).ceil\n      split_volume = volume_ul.fdiv(factor)\n      return P1000_PRE, \"Split transfer into \u003cb\u003e#{factor}\u003c/b\u003e seperate transfers of \u003cb\u003e#{split_volume}uL\u003c/b\u003e.\"\n    end\n  end\n\n  # helper method for simple incubations\n  def incubate(samples, time)\n    show do\n      title 'Incubate Sample Solutions'\n      note \"Let \u003cb\u003e#{samples.to_sentence}\u003c/b\u003e incubate for \u003cb\u003e#{time}\u003c/b\u003e at room temperature.\"\n      check \"Set a timer for \u003cb\u003e#{time}\u003c/b\u003e\"\n    end\n  end\n\n  def centrifuge_columns(flow_instructions: nil)\n    columns = sample_labels.map { |s| \"#{SAMPLE_COLUMN}-#{s}\"}\n    \n    show do\n      title \" Centrifuge Columns for #{CENTRIFUGE_TIME}\"\n      warning \"Ensure both tube caps are closed\"\n      raw centrifuge_proc(\"Column\", columns, CENTRIFUGE_TIME, \"\", AREA)\n      check flow_instructions if flow_instructions\n    end\n  end\n\n  def prepare_buffers\n    # add sa water to dtt/trna\n    transfer_and_vortex(\n        \"Prepare #{DTT}\", \n        SA_WATER, \n        DTT, \n        25,\n        to_contents: 'full'\n    )\n\n    # add dtt solution to lysis buffer\n    operations.each do |op|\n      transfer_and_vortex(\n        \"Prepare #{LYSIS_BUFFER}-#{op.temporary[SAMPLE_KEY]}\", \n        DTT, \n        \"#{LYSIS_BUFFER}-#{op.temporary[SAMPLE_KEY]}\", \n        10,\n        to_contents: 'full'\n      )\n    end    \n\n    # prepare wash buffer 2 with ethanaol\n    transfer_and_vortex(\n      \"Prepare #{WASH2}\", \n      ETHANOL, \n      WASH2, \n      1600,\n      warning: 'Do not use other grades of ethanol.',\n      to_contents: 'full'\n    )\n  end\n  \n  # transfer plasma Samples into lysis buffer and incubate\n  def lyse_samples\n    operations.each do |op|\n      transfer_and_vortex(\n        \"Lyse Sample #{INCOMING_SAMPLE}-#{op.temporary[SAMPLE_KEY]}\", \n        \"#{INCOMING_SAMPLE}-#{op.temporary[SAMPLE_KEY]}\",\n        \"#{LYSIS_BUFFER}-#{op.temporary[SAMPLE_KEY]}\", \n        300,\n        to_contents: 'full'\n      )\n    end\n    \n    lysed_samples = operations.map { |op| \"#{LYSIS_BUFFER}-#{op.temporary[SAMPLE_KEY]}\" }\n    incubate(lysed_samples, \"15 minutes\")\n  end\n\n  def add_ethanol\n    operations.each do |op|\n      transfer_and_vortex(\n        \"Add Buffer Ethanol to #{LYSIS_BUFFER}-#{op.temporary[SAMPLE_KEY]}\", \n        ETHANOL, \n        \"#{LYSIS_BUFFER}-#{op.temporary[SAMPLE_KEY]}\", \n        1200,\n        to_contents: 'full'\n      )\n    end\n  end\n\n  def add_sample_to_column(op)\n    from = \"#{LYSIS_BUFFER}-#{op.temporary[SAMPLE_KEY]}\"\n    to = \"#{SAMPLE_COLUMN}-#{op.temporary[SAMPLE_KEY]}\"\n    transfer_carefully(from, to, 500, from_type: 'sample', to_type: 'column', to_contents: 'empty')\n  end\n\n  def change_collection_tubes\n    sample_columns = operations.map { |op| \"#{SAMPLE_COLUMN}-#{op.temporary[SAMPLE_KEY]}\"}\n    show do\n      title 'Change Collection Tubes'\n      sample_columns.each do |column|\n        check \"Transfer \u003cb\u003e#{column}\u003c/b\u003e to a new collection tube.\"\n      end\n      note \"Discard previous collection tubes.\"\n    end\n  end\n\n  def add_wash_1\n    sample_columns = operations.each do |op| \n      column = \"#{SAMPLE_COLUMN}-#{op.temporary[SAMPLE_KEY]}\"\n      transfer_carefully(WASH1, column, 500, from_type: 'buffer', to_type: 'column', to_contents: 'full')\n    end\n  end\n\n  def add_wash_2\n    sample_columns = operations.each do |op| \n      column = \"#{SAMPLE_COLUMN}-#{op.temporary[SAMPLE_KEY]}\"\n      transfer_carefully(WASH2, column, 500, from_type: 'buffer', to_type: 'column', to_contents: 'full')\n    end\n  end\n  \n  def transfer_carefully(from, to, volume_ul, from_type: nil, to_type: nil, to_contents: nil)\n    pipette, extra_note = pipette_decision(volume_ul)\n      \n    from_component = from.split('-')[0]\n    to_component = to.split('-')[0]\n    \n    img = nil\n    if KIT_SVGs[from_component] \u0026\u0026 KIT_SVGs[to_component]\n      from_label = from.split('-').join(\"\\n\")\n      from_svg = draw_svg(KIT_SVGs[from_component], svg_label: from_label, opened: true, contents: 'full')\n      to_label = to.split('-').join(\"\\n\")\n      to_svg = draw_svg(KIT_SVGs[to_component], svg_label: to_label, opened: true, contents: to_contents)\n      img = make_transfer(from_svg, to_svg, 250, \"#{volume_ul}ul\", \"(#{pipette})\")\n    end\n    show do \n      title \"Add #{from_type || from} to #{to_type || to}\"\n      note \"\u003cb\u003eCarefully\u003c/b\u003e open #{to_type} \u003cb\u003e#{to}\u003c/b\u003e lid.\"\n      check \"\u003cb\u003eCarefully\u003c/b\u003e Add \u003cb\u003e#{volume_ul}uL\u003c/b\u003e of #{from_type} \u003cb\u003e#{from}\u003c/b\u003e to \u003cb\u003e#{to}\u003c/b\u003e using a #{pipette} pipette.\"\n      note extra_note if extra_note\n      note display_svg(img, 0.75) if img\n      check 'Discard pipette tip.'\n      note \"\u003cb\u003eSlowly\u003c/b\u003e close lid of \u003cb\u003e#{to}\u003c/b\u003e\"\n    end\n  end\n\n  def transfer_column_to_e6\n    show do\n      title 'Transfer Columns'\n      warning \"Make sure the bottom of the E5 and E6 columns  did not touch any fluid from the previous collection tubes. When in doubt, centrifuge for 1 more minute and replace collection tubes again.\"\n      operations.each do |op|\n        column = \"#{SAMPLE_COLUMN}-#{op.temporary[SAMPLE_KEY]}\"\n        extract_tube = \"#{RNA_EXTRACT}-#{op.temporary[SAMPLE_KEY]}\"\n        check \"Transfer column \u003cb\u003e#{column}\u003c/b\u003e to \u003cb\u003e#{extract_tube}\u003c/b\u003e\"\n      end\n    end\n  end\n\n  def elute\n    show do \n      title 'Add Elution Buffer'\n      note \"Add buffer to center of columns.\"\n      operations.each do |op|\n        column = \"#{SAMPLE_COLUMN}-#{op.temporary[SAMPLE_KEY]}\"\n        check \"Add \u003cb\u003e60uL\u003c/b\u003e from \u003cb\u003e#{SA_WATER}\u003c/b\u003e to column \u003cb\u003e#{column}\u003c/b\u003e\"\n      end\n    end\n  end\n\n  def finish_up\n    show do\n      title \"Prepare Samples for Storage\"\n      operations.each do |op|\n        column = \"#{SAMPLE_COLUMN}-#{op.temporary[SAMPLE_KEY]}\"\n        extract_tube = \"#{RNA_EXTRACT}-#{op.temporary[SAMPLE_KEY]}\"\n        check \"Remove column \u003cb\u003e#{column}\u003c/b\u003e from \u003cb\u003e#{extract_tube}\u003c/b\u003e, and discard \u003cb\u003e#{column} in #{WASTE_PRE}\u003c/b\u003e\"\n      end\n      extract_tubes = sample_labels.map { |s| \"#{RNA_EXTRACT}-#{s}\"}\n      check \"Place \u003cb\u003e#{extract_tubes.to_sentence}\u003c/b\u003e on cold rack\"\n    end\n  end\n\n  def disinfect\n    show do\n      title 'Disinfect Items'\n      check 'Spray and wipe down all reagent and sample tubes with bleach and ethanol.'\n    end\n  end\n\n  def store\n    show do\n      title 'Store Items'\n      extract_tubes = sample_labels.map { |s| \"#{RNA_EXTRACT}-#{s}\"}\n      note \"Store \u003cb\u003e#{extract_tubes.to_sentence}\u003c/b\u003e in the fridge on a cold rack if the amplification module will be proceeded immediately.\"\n      \n      note \"Store \u003cb\u003e#{extract_tubes.to_sentence}\u003c/b\u003e in -20C freezer if proceeding with the amplification module later.\"\n    end\n  end\n\n  def cleanup\n    show do\n      title \"Clean up Waste\"\n      warning \"DO NOT dispose of liquid waste and bleach into #{GuSCN_WASTE}, this can produce dangerous gas.\"\n      bullet \"Dispose of liquid waste in bleach down the sink with running water.\"\n      bullet \"Dispose of remaining tubes into #{WASTE_PRE}.\"\n    end\n\n    show do\n      title \"Clean Biosafety Cabinet (BSC)\"\n      note \"Place items in the BSC off to the side.\"\n      note \"Spray surface of BSC with 10% bleach. Wipe clean using paper towel.\"\n      note \"Spray surface of BSC with 70% ethanol. Wipe clean using paper towel.\"\n      note \"After cleaning, dispose of gloves and paper towels in #{WASTE_PRE}.\"\n    end\n  end\n\n  \n  \n  ####################################################################################\n  #### SVGs                                                                       ####\n  ####################################################################################\n  def roundedtube(opened: false, contents: 'empty')\n    _roundedtube = SVGElement.new(boundx: 46.92, boundy: 132.74)\n    _roundedtube.add_child(\n        '\u003csvg\u003e\u003cdefs\u003e\u003cstyle\u003e.cls-1{fill:#26afe5;}.cls-2{fill:#fff;}.cls-2,.cls-3{stroke:#231f20;stroke-miterlimit:10;stroke-width:0.5px;}.cls-3{fill:none;}\u003c/style\u003e\u003c/defs\u003e\u003ctitle\u003eUntitled-18\u003c/title\u003e\u003cpath class=\"cls-1\" d=\"M412.76,285.62c-8.82,5.75-17.91,3.62-26.54.87l-10.47,3v45.4c0,.05,0,.1,0,.15.12,1.91,4.52,35.39,19.95,31.76,0,0,12.62,4.63,17.42-30.86a2.67,2.67,0,0,0,0-.37Z\" transform=\"translate(-372.39 -241.25)\"/\u003e\u003cpath class=\"cls-1\" d=\"M383.88,285.72a15.52,15.52,0,0,0-8.13-.66v4.44l10.47-3Z\" transform=\"translate(-372.39 -241.25)\"/\u003e\u003crect class=\"cls-2\" x=\"5.5\" y=\"2.53\" width=\"33.11\" height=\"9.82\" rx=\"2.36\" ry=\"2.36\"/\u003e\u003crect class=\"cls-2\" x=\"0.25\" y=\"0.25\" width=\"42.88\" height=\"7.39\" rx=\"2.36\" ry=\"2.36\"/\u003e\u003cpath class=\"cls-3\" d=\"M412.06,252\" transform=\"translate(-372.39 -241.25)\"/\u003e\u003cpath class=\"cls-3\" d=\"M412.67,253.6a3.88,3.88,0,0,0,3.29-2.79,4.85,4.85,0,0,0-.42-4.28\" transform=\"translate(-372.39 -241.25)\"/\u003e\u003cpath class=\"cls-3\" d=\"M412.67,255.44a6,6,0,0,0,6.16-4.86,5.79,5.79,0,0,0-3.17-7\" transform=\"translate(-372.39 -241.25)\"/\u003e\u003cpath class=\"cls-3\" d=\"M375.39,257.57v77.6c0,.05,0,.1,0,.15.12,1.91,4.52,35.39,19.95,31.76,0,0,12.62,4.63,17.42-30.86a2.66,2.66,0,0,0,0-.37l-.61-78.29a2.52,2.52,0,0,0-2.52-2.5H377.91A2.52,2.52,0,0,0,375.39,257.57Z\" transform=\"translate(-372.39 -241.25)\"/\u003e\u003crect class=\"cls-2\" x=\"0.53\" y=\"11.4\" width=\"42.32\" height=\"4.79\" rx=\"2.4\" ry=\"2.4\"/\u003e\u003c/svg\u003e'\n        ).translate!(0,70)\n  end\n  \n  def screwbottle(opened: false, contents: 'empty')\n    _screwbottle = SVGElement.new(boundx: 46.92, boundy: 132.74)\n    _screwbottle.add_child(\n        '\u003csvg\u003e\u003cdefs\u003e\u003cstyle\u003e.cls-1{fill:#26afe5;}.cls-2,.cls-3{fill:none;}.cls-3,.cls-4{stroke:#231f20;stroke-miterlimit:10;stroke-width:0.5px;}.cls-4{fill:#fff;}\u003c/style\u003e\u003c/defs\u003e\u003cpath class=\"cls-1\" d=\"M377.92,325.7c-4.23-1-8.46.27-11.89,2v31.86a8.73,8.73,0,0,0,8.71,8.71h41.68a8.73,8.73,0,0,0,8.71-8.71V328.25c-9.24.24-7.87,3.46-19.44,7.63S387.64,328,377.92,325.7Z\" transform=\"translate(-365.78 -243.8)\"/\u003e\u003cpath class=\"cls-2\" d=\"M369,280.29\" transform=\"translate(-365.78 -243.8)\"/\u003e\u003crect class=\"cls-3\" x=\"0.25\" y=\"43.66\" width=\"59.09\" height=\"80.08\" rx=\"8.6\" ry=\"8.6\"/\u003e\u003cpath class=\"cls-4\" d=\"M395.58,244c-16.32,0-29.55,3.59-29.55,8V285.6c0,4.42,13.23,8,29.55,8s29.55-3.59,29.55-8V252.05C425.12,247.63,411.89,244,395.58,244Z\" transform=\"translate(-365.78 -243.8)\"/\u003e\u003cellipse class=\"cls-4\" cx=\"29.8\" cy=\"8.12\" rx=\"22.86\" ry=\"4.76\"/\u003e\u003cline class=\"cls-3\" x1=\"5.46\" y1=\"14.46\" x2=\"5.46\" y2=\"41.93\"/\u003e\u003cline class=\"cls-3\" x1=\"30.86\" y1=\"18.98\" x2=\"30.86\" y2=\"46.45\"/\u003e\u003cline class=\"cls-3\" x1=\"55.9\" y1=\"12.89\" x2=\"55.9\" y2=\"40.36\"/\u003e\u003cline class=\"cls-3\" x1=\"44.1\" y1=\"17.66\" x2=\"44.1\" y2=\"45.13\"/\u003e\u003cline class=\"cls-3\" x1=\"17.63\" y1=\"17.66\" x2=\"17.63\" y2=\"45.13\"/\u003e\u003c/svg\u003e'\n        ).translate!(0, 70)\n  end\n  \n  def samplecolumn(opened: false, contents: 'empty')\n    column =  SVGElement.new(boundx: 46.92, boundy: 132.74)\n    if contents == 'empty' \u0026\u0026 !opened\n      column.add_child(\n        '\u003csvg\u003e\u003cdefs\u003e\u003cstyle\u003e.cls-1_sc{fill:#fff;}.cls-1_sc,.cls-2_sc{stroke:#231f20;stroke-miterlimit:10;stroke-width:0.5px;}.cls-2_sc{fill:none;}\u003c/style\u003e\u003c/defs\u003e\u003cpath class=\"cls-1_sc\" d=\"M375.23,260.43V338c0,.05,0,.1,0,.15.12,1.91,4.52,35.39,19.95,31.76,0,0,12.62,4.63,17.42-30.86a2.66,2.66,0,0,0,0-.37L412,260.41a2.52,2.52,0,0,0-2.52-2.5H377.75A2.52,2.52,0,0,0,375.23,260.43Z\" transform=\"translate(-371.72 -237.72)\"/\u003e\u003crect class=\"cls-1_sc\" x=\"5.5\" y=\"2.53\" width=\"33.11\" height=\"9.82\" rx=\"2.36\" ry=\"2.36\"/\u003e\u003crect class=\"cls-1_sc\" x=\"3.51\" y=\"9.99\" width=\"36.77\" height=\"4.72\" rx=\"1.19\" ry=\"1.19\"/\u003e\u003cpath class=\"cls-1_sc\" d=\"M377.22,252.44v51.26a1.65,1.65,0,0,0,.85,1.44l5.56,3.06a1.65,1.65,0,0,1,.85,1.44v7.3a1.65,1.65,0,0,0,1.65,1.65h14.54a1.65,1.65,0,0,0,1.65-1.65v-7.25a1.65,1.65,0,0,1,.91-1.48l6.18-3.09a1.65,1.65,0,0,0,.91-1.48V252.44\" transform=\"translate(-371.72 -237.72)\"/\u003e\u003crect class=\"cls-1_sc\" x=\"14.16\" y=\"70.95\" width=\"15.06\" height=\"6.09\" rx=\"0.98\" ry=\"0.98\"/\u003e\u003crect class=\"cls-1_sc\" x=\"0.25\" y=\"0.25\" width=\"42.88\" height=\"7.39\" rx=\"2.36\" ry=\"2.36\"/\u003e\u003cpath class=\"cls-2_sc\" d=\"M416.1,248\" transform=\"translate(-371.72 -237.72)\"/\u003e\u003cpath class=\"cls-2_sc\" d=\"M411.38,248.51\" transform=\"translate(-371.72 -237.72)\"/\u003e\u003cpath class=\"cls-2_sc\" d=\"M412,250.08a3.88,3.88,0,0,0,3.29-2.79,4.85,4.85,0,0,0-.42-4.28\" transform=\"translate(-371.72 -237.72)\"/\u003e\u003cpath class=\"cls-2_sc\" d=\"M412,251.91a6,6,0,0,0,6.16-4.86,5.79,5.79,0,0,0-3.17-7\" transform=\"translate(-371.72 -237.72)\"/\u003e\u003crect class=\"cls-1_sc\" x=\"1.05\" y=\"17.78\" width=\"42.32\" height=\"4.79\" rx=\"2.4\" ry=\"2.4\"/\u003e\u003c/svg\u003e'\n        )\n    elsif contents == 'no-collector' \u0026\u0026 closed\n      column.add_child(\n        '\u003csvg\u003e\u003cdefs\u003e\u003cstyle\u003e.cls-1_sc{fill:#fff;}.cls-1_sc,.cls-2_sc{stroke:#231f20;stroke-miterlimit:10;stroke-width:0.5px;}.cls-2_sc{fill:none;}\u003c/style\u003e\u003c/defs\u003e\u003crect class=\"cls-1_sc\" x=\"5.5\" y=\"2.53\" width=\"33.11\" height=\"9.82\" rx=\"2.36\" ry=\"2.36\"/\u003e\u003crect class=\"cls-1_sc\" x=\"3.51\" y=\"9.99\" width=\"36.77\" height=\"4.72\" rx=\"1.19\" ry=\"1.19\"/\u003e\u003cpath class=\"cls-1_sc\" d=\"M377.46,280.13v51.26a1.65,1.65,0,0,0,.85,1.44l5.56,3.06a1.65,1.65,0,0,1,.85,1.44v7.3a1.65,1.65,0,0,0,1.65,1.65h14.54a1.65,1.65,0,0,0,1.65-1.65v-7.25a1.65,1.65,0,0,1,.91-1.48l6.18-3.09a1.65,1.65,0,0,0,.91-1.48V280.13\" transform=\"translate(-371.95 -265.42)\"/\u003e\u003crect class=\"cls-1_sc\" x=\"14.16\" y=\"70.95\" width=\"15.06\" height=\"6.09\" rx=\"0.98\" ry=\"0.98\"/\u003e\u003crect class=\"cls-1_sc\" x=\"0.25\" y=\"0.25\" width=\"42.88\" height=\"7.39\" rx=\"2.36\" ry=\"2.36\"/\u003e\u003cpath class=\"cls-2_sc\" d=\"M416.34,275.65\" transform=\"translate(-371.95 -265.42)\"/\u003e\u003cpath class=\"cls-2_sc\" d=\"M411.62,276.2\" transform=\"translate(-371.95 -265.42)\"/\u003e\u003cpath class=\"cls-2_sc\" d=\"M412.23,277.77a3.88,3.88,0,0,0,3.29-2.79,4.85,4.85,0,0,0-.42-4.28\" transform=\"translate(-371.95 -265.42)\"/\u003e\u003cpath class=\"cls-2_sc\" d=\"M412.23,279.61a6,6,0,0,0,6.16-4.86,5.79,5.79,0,0,0-3.17-7\" transform=\"translate(-371.95 -265.42)\"/\u003e\u003c/svg\u003e'\n        )\n    else\n      column.add_child(samplecolumn.translate!(0,-70)) #default to closed and empty if options could not be matched\n    end\n    column.translate!(0,70)\n  end\n  \n  def collectiontube(contents: 'empty')\n    ctube = SVGElement.new(boundx: 46.92, boundy: 132.74)\n    if contents == 'empty'\n      ctube.add_child(\n        '\u003csvg\u003e\u003cdefs\u003e\u003cstyle\u003e.cls-1_collection_tube{fill:none;stroke:#231f20;stroke-miterlimit:10;stroke-width:0.5px;}\u003c/style\u003e\u003c/defs\u003e\u003cpath class=\"cls-1_collection_tube\" d=\"M377.69,251.62v77.6c0,.05,0,.1,0,.15.12,1.91,4.52,35.39,19.95,31.76,0,0,12.62,4.63,17.42-30.86a2.66,2.66,0,0,0,0-.37l-.61-78.29a2.52,2.52,0,0,0-2.52-2.5H380.21A2.52,2.52,0,0,0,377.69,251.62Z\" transform=\"translate(-374.97 -246.46)\"/\u003e\u003crect class=\"cls-1_collection_tube\" x=\"0.25\" y=\"0.25\" width=\"42.32\" height=\"4.79\" rx=\"2.4\" ry=\"2.4\"/\u003e\u003c/svg\u003e'\n        )\n    elsif contents == 'full'\n      ctube.add_child(\n        '\u003csvg\u003e\u003cdefs\u003e\u003cstyle\u003e.cls-1_collection_tube{fill:#26afe5;}.cls-2_collection_tube{fill:#fff;}.cls-2_collection_tube,.cls-3_collection_tube{stroke:#231f20;stroke-miterlimit:10;stroke-width:0.5px;}.cls-3_collection_tube{fill:none;}\u003c/style\u003e\u003c/defs\u003e\u003cpath class=\"cls-1_collection_tube\" d=\"M412.76,285.62c-8.82,5.75-17.91,3.62-26.54.87l-10.47,3v45.4c0,.05,0,.1,0,.15.12,1.91,4.52,35.39,19.95,31.76,0,0,12.62,4.63,17.42-30.86a2.67,2.67,0,0,0,0-.37Z\" transform=\"translate(-372.39 -241.25)\"/\u003e\u003cpath class=\"cls-1_collection_tube\" d=\"M383.88,285.72a15.52,15.52,0,0,0-8.13-.66v4.44l10.47-3Z\" transform=\"translate(-372.39 -241.25)\"/\u003e\u003crect class=\"cls-2_collection_tube\" x=\"5.5\" y=\"2.53\" width=\"33.11\" height=\"9.82\" rx=\"2.36\" ry=\"2.36\"/\u003e\u003c/svg\u003e'\n        )\n    end\n  end\n  \n  def tube(opened: false, contents: 'empty')\n    tube = SVGElement.new(boundx: 46.92, boundy: 132.74)\n    \n    if contents == 'empty' \u0026\u0026 !opened\n      tube.add_child(\n        '\u003csvg\u003e\u003cdefs\u003e\u003cstyle\u003e.cls-1_tube{fill:#fff;}.cls-1_tube,.cls-2_tube{stroke:#231f20;stroke-miterlimit:10;stroke-width:0.5px;}.cls-2_tube{fill:none;}\u003c/style\u003e\u003c/defs\u003e\u003crect class=\"cls-1_tube\" x=\"5.5\" y=\"2.53\" width=\"33.11\" height=\"9.82\" rx=\"2.36\" ry=\"2.36\"/\u003e\u003crect class=\"cls-1_tube\" x=\"0.25\" y=\"0.25\" width=\"42.88\" height=\"7.39\" rx=\"2.36\" ry=\"2.36\"/\u003e\u003cpath class=\"cls-2_tube\" d=\"M411.36,243.86\" transform=\"translate(-371.69 -233.08)\"/\u003e\u003cpath class=\"cls-2_tube\" d=\"M412,245.43a3.88,3.88,0,0,0,3.29-2.79,4.85,4.85,0,0,0-.42-4.28\" transform=\"translate(-371.69 -233.08)\"/\u003e\u003cpath class=\"cls-2_tube\" d=\"M412,247.27a6,6,0,0,0,6.16-4.86,5.79,5.79,0,0,0-3.17-7\" transform=\"translate(-371.69 -233.08)\"/\u003e\u003crect class=\"cls-1_tube\" x=\"0.53\" y=\"11.4\" width=\"42.32\" height=\"4.79\" rx=\"2.4\" ry=\"2.4\"/\u003e\u003cpath class=\"cls-2_tube\" d=\"M374.62,249.27V304.5l11.32,68c.8,4.79,4.61,5.75,7.86,5.09s4.39-5.33,4.39-5.33l13.16-67.79V249.27Z\" transform=\"translate(-371.69 -233.08)\"/\u003e\u003c/svg\u003e'\n        )\n    elsif contents == 'empty' \u0026\u0026 opened\n      tube.add_child(\n        '\u003csvg\u003e\u003cdefs\u003e\u003cstyle\u003e.cls-1_tube{fill:none;}.cls-1_tube,.cls-2_tube{stroke:#231f20;stroke-miterlimit:10;stroke-width:0.5px;}.cls-2_tube{fill:#fff;}\u003c/style\u003e\u003c/defs\u003e\u003ctitle\u003eUntitled-1\u003c/title\u003e\u003cpath class=\"cls-1_tube\" d=\"M410.51,263.07\" transform=\"translate(-371.13 -215.85)\"/\u003e\u003cpath class=\"cls-1_tube\" d=\"M411.12,264.64a3.88,3.88,0,0,0,3.29-2.79,4.85,4.85,0,0,0-.42-4.28\" transform=\"translate(-371.13 -215.85)\"/\u003e\u003cpath class=\"cls-1_tube\" d=\"M411.12,266.47a6,6,0,0,0,6.16-4.86,5.79,5.79,0,0,0-3.17-7\" transform=\"translate(-371.13 -215.85)\"/\u003e\u003crect class=\"cls-2_tube\" x=\"0.25\" y=\"47.83\" width=\"42.32\" height=\"4.79\" rx=\"2.4\" ry=\"2.4\"/\u003e\u003cpath class=\"cls-1_tube\" d=\"M373.78,268.47V323.7l11.32,68c.8,4.79,4.61,5.75,7.86,5.09s4.39-5.33,4.39-5.33l13.16-67.79V268.47Z\" transform=\"translate(-371.13 -215.85)\"/\u003e\u003crect class=\"cls-2_tube\" x=\"394.99\" y=\"233.39\" width=\"33.11\" height=\"9.82\" rx=\"2.36\" ry=\"2.36\" transform=\"translate(236.03 -411.02) rotate(84.22)\"/\u003e\u003crect class=\"cls-2_tube\" x=\"393.55\" y=\"233.89\" width=\"42.88\" height=\"7.39\" rx=\"2.36\" ry=\"2.36\" transform=\"translate(238.41 -415.09) rotate(84.22)\"/\u003e\u003c/svg\u003e'\n        )\n    end\n    tube.translate!(0,70)\n  end\n  \n  # svg_func: a symbol method name for a function that returns an SVGElement\n  # svg_label: label for svg\n  # opts: option hash to be applied to svg_func as named parameters\n  #\n  # example: svg = draw_svg(:tube, svg_label: \"Hello\\nWorld\", opened: true, full: true)\n  def draw_svg(svg_func, svg_label: nil, **opts)\n    svg = method(svg_func).call(**opts)\n    svg = label_object(svg, svg_label) if svg_label\n    svg\n  end\n  \n  def label_object(svg, _label)\n    def label_helper(svg, labels, offsety = 0)\n      l = label(labels.shift, \"font-size\".to_sym =\u003e 25)\n      l.align!('center-center')\n      l.translate!(svg.boundx / 2, svg.boundy / 2 + offsety.to_i)\n      svg.add_child(l)\n      return label_helper(svg, labels, offsety + 25) unless labels.empty?\n      return svg\n    end\n    \n    labels = _label.split(\"\\n\")\n    return label_helper(svg, labels, 0)\n  end\nend","precondition":"eval Library.find_by_name(\"OLAScheduling\").code(\"source\").content\nextend OLAScheduling\n\nBATCH_SIZE = 2\ndef precondition(op)\n  schedule_same_kit_ops(op)\n  true\nend","cost_model":"def cost(op)\n  { labor: 0, materials: 0 }\nend","documentation":"Blood CD4+ cells are negatively selected and lysed. Magnetic beads and antibodies are used to separate unwanted cells.","test":"","timing":null}},{"sample_types":[{"id":1,"name":"OLASimple Sample","description":"Patient sample and OLA kit","created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","field_types":[{"id":1,"parent_id":1,"name":"Patient ID","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":2,"parent_id":1,"name":"Secondary Patient ID","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-05-27T15:06:37.000-07:00","updated_at":"2020-05-27T15:06:37.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]}]}],"object_types":[{"id":7,"name":"OLA plasma","description":"Patient plasma in tube identified as SXXX. Starting point for OLA Simple RT-PCR workflow.","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-05-27T15:06:38.000-07:00","updated_at":"2020-05-27T15:06:38.000-07:00","unit":"OLASimple Sample","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":null,"prefix":"","rows":null,"columns":null,"sample_type_name":"OLASimple Sample"}],"operation_type":{"name":"OLASimple Sample Preparation","category":"OLASimple","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"output","name":"Patient Sample","sample_types":["OLASimple Sample"],"object_types":["OLA plasma"],"part":false,"array":false,"routing":"S","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"string","role":"input","name":"Patient Sample Identifier","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"string","role":"input","name":"Kit Identifier","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"needs 'OLASimple/OLAConstants'\nneeds 'OLASimple/OLAKitIDs'\nclass Protocol\n  include OLAKitIDs\n  OUTPUT = 'Patient Sample'\n  PATIENT_ID_INPUT = 'Patient Sample Identifier'\n  KIT_ID_INPUT = 'Kit Identifier'\n\n  UNIT = \"S\"\n  OUTPUT_COMPONENT = \"\"\n\n  def main\n    operations.make\n    operations.each do |op|\n      if debug\n        op.temporary[OLAConstants::PATIENT_KEY] = \"a patient id\"\n        op.temporary[OLAConstants::KIT_KEY] = \"001\"\n      else\n        op.temporary[OLAConstants::PATIENT_KEY] = op.input(PATIENT_ID_INPUT).value\n        op.temporary[OLAConstants::KIT_KEY] = op.input(KIT_ID_INPUT).value\n      end\n    end\n    \n    kit_groups = operations.group_by { |op| op.temporary[OLAConstants::KIT_KEY] }\n    \n    kit_groups.each do |kit_num, ops|\n      first_module_setup(ops, kit_num)\n      set_output_components(ops, OUTPUT_COMPONENT, UNIT)\n    end\n    \n    operations.running.each do |op|\n      show do\n        title 'Put barcodes on things and stuff'\n        note \"Operation #{op.id}\"\n        note \"PATIENT_KEY: #{op.temporary[OLAConstants::PATIENT_KEY]}\"\n        note \"KIT_KEY: #{op.temporary[OLAConstants::KIT_KEY]}\"\n        note \"SAMPLE_KEY: #{op.temporary[OLAConstants::SAMPLE_KEY]}\"\n      end\n    end\n    {}\n\n  end\n  \n  # Since this is the first protocol in the workflow, we\n  # pause here to link the incoming patient ids to the kit sample numbers\n  # in a coherent and deterministic way.\n  #\n  # Makes the assumptions that all operations here are from the same kit\n  # with output items made, and have a suitable batch size\n  def first_module_setup(operations, kit_num)\n      \n    if operations.size \u003e OLAConstants::BATCH_SIZE\n      operations.each do |op|\n        op.error(:batch_size_too_big, \"operations.size operations batched with #{kit_num}, but max batch size is #{BATCH_SIZE}.\")\n      end\n      return\n    end\n    assign_sample_aliases_from_kit_id(operations, kit_num)\n\n    data_associations = []\n    operations.each do |op|\n      new_das = associate_kit_information_lazy(\n        op.output(OUTPUT).item,\n        kit_num: op.temporary[OLAConstants::KIT_KEY], \n        sample_num: op.temporary[OLAConstants::SAMPLE_KEY], \n        patient: op.temporary[OLAConstants::PATIENT_KEY]\n      )\n      data_associations.concat(new_das)\n    end\n    \n    DataAssociation.import data_associations, on_duplicate_key_update: [:object]\n  end\n\nend\n","precondition":"eval Library.find_by_name(\"OLAScheduling\").code(\"source\").content\nextend OLAScheduling\n\ndef precondition(_op)\n  if _op.plan \u0026\u0026 _op.plan.status != 'planning'\n    schedule_same_kit_ops(_op)\n  end\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"","timing":null}},{"library":{"name":"JobComments","category":"OLASimple","code_source":"module JobComments\n  \n  COMMENT_KEY = \"Technician Comment\"\n  \n  def accept_comments\n    comments = ask_for_comments\n    unless comments.blank?\n      associate_comments_to_operation_and_plan comments\n    end\n  end\n  \n  # Associates the comment entered by the lab technician to the operations and plans\n  # of the protocol that uses this library.\n  #\n  # @param [String] the feedback entered by the lab technician.\n  def associate_comments_to_operation_and_plan comments\n    full_comment_key = COMMENT_KEY + \"- job #{jid}\"\n  \n    operations.each do |op|\n      op.associate(full_comment_key, comments)\n      op.plan.associate(full_comment_key, comments)\n    end\n  end\n\n  \n  def ask_for_comments\n    comment = show do\n      title \"Leave Comments\"\n      \n      note \"If anything out of the ordinary happened during this protocol, make a note of it here.\"\n      \n      warning \"Be as specific as possible, mentioning names of steps and labels of involved items when appropriate.\"\n      warning \"If you have been dealing with contaminants, wash your hands thoroughly before interacting with the keyboard or tablet screen.\"\n      \n      get \"text\", var: \"response_key\", label: \"Enter your feedback here\", default: \"\"\n    end\n    comment[:response_key] # return\n  end\nend"}},{"library":{"name":"NetworkRequests","category":"OLASimple","code_source":"# This library allows complex network requests to be made from protocols\n# so that external APIs can be consulted during protocol execution\n\nrequire 'net/https'\nmodule NetworkRequests\n  \n  # make post request to a URL, sending a Upload object as a file\n  # returns the http response\n  def post_file(post_url, key, aq_upload)\n    file_url = aq_upload.url\n    file_name = aq_upload.name\n    file_obj = URI.open(file_url)\n    \n    uri = URI(post_url)\n    req = Net::HTTP::Post.new(uri)\n    req.set_form([[key, file_obj, {'filename': file_name}]], 'multipart/form-data')\n    \n    res = Net::HTTP.start(uri.hostname, uri.port) do |http|\n      http.request(req)\n    end\n    return res\n  end\n  \nend"}},{"library":{"name":"OLAConstants","category":"OLASimple","code_source":"needs \"OLASimple/OLAKits\"\n\nmodule OLAConstants\n  include OLAKits\n  \n  ##########################################\n  # TECHNICAL (SHOULD NOT NEED TO CHANGE)\n  ##########################################\n\n  OLA_IP_API_URL = \"http://ola_image_processing:5000/api/processimage\" # URL of OLASimple strip image processing service \n\n  ##########################################\n  # DATA ASSOCIATION KEYS (DO NOT CHANGE)\n  ##########################################\n  #\n  PATIENT_KEY = :patient\n  TECH_KEY = :technician\n  ALIAS_KEY = :alias\n  KIT_KEY = :kit\n  UNIT_KEY = :unit\n  COMPONENT_KEY = :component\n  SAMPLE_KEY = :sample\n  SCANNED_IMAGE_UPLOAD_KEY = :scanned_image_upload\n  SCANNED_IMAGE_UPLOAD_ID_KEY = :scanned_image_upload_id\n\n  ##########################################\n  # KIT SELECTION\n  ##########################################\n\n  KIT_SELECTION = OLAKits.rt_pcr()\n  KIT_NAME = KIT_SELECTION[\"name\"]\n  SAMPLE_PREP_UNIT = KIT_SELECTION[\"sample prep\"]\n  PCR_UNIT = KIT_SELECTION[\"pcr\"]\n  LIGATION_UNIT = KIT_SELECTION[\"ligation\"]\n  DETECTION_UNIT = KIT_SELECTION[\"detection\"]\n  ANALYSIS_UNIT = KIT_SELECTION[\"analysis\"]\n  COLORS = DETECTION_UNIT[\"Mutation Colors\"]\n\n  ##########################################\n  # LAB SPECIFICATIONS\n  ##########################################\n  SAVE_SAMPLES = false\n  SUPERVISOR = \"Nuttada P. or Cami C.\"\n\n  ##########################################\n  # KIT SPECIFICATIONS\n  ##########################################\n\n  # mutations\n  MUTATIONKEY = :mutations\n\n  # kit components\n  DILUENT_A = \"Diluent A\" # what to call the Diluent A tube (i.e. water)\n  STOP_MIX = \"stop mix\" # what to call the input samples (cell lysates)\n  GOLD_MIX = \"gold mix\"\n  STRIP = \"detection strip\"\n  STRIPS = STRIP.pluralize(10)\n  BAND = \"band\"\n  BANDS = \"bands\"\n  PANEL = \"panel\"\n  AQUARIUM = \"Aquarium\"\n  \n  BATCH_SIZE = 2 # Changing batch size must be done in OLAScheduling as well as here\n\n  ##########################################\n  # CODONS\n  ##########################################\n\n  pcr_pkg_color = \"STEELBLUE\"\n  lig_pkg_color = \"PALETURQUOISE\"\n  det_pkg_color = \"MEDIUMPURPLE\"\n  SAMPLE_PREP_PKG_NAME = \"sample prep package\"\n  PCR_PKG_NAME = \"PCR package\"\n  LIG_PKG_NAME = \"ligation package\"\n  DET_PKG_NAME = \"detection package\"\n\n  # names of sample field value and validate kit field types\n  SAMPLE_PREP_FIELD_VALUE = \"Sample Prep Pack\"\n  PCR_FIELD_VALUE = \"PCR Pack\"\n  LIGATION_FIELD_VALUE = \"Ligation Pack\"\n  DETECTION_FIELD_VALUE = \"Detection Pack\"\n  KIT_FIELD_VALUE = \"Kit\"\n  CODONS_FIELD_VALUE = \"Codons\"\n  CODON_COLORS_FIELD_VALUE = \"Codon Colors\"\n  NUM_SAMPLES_FIELD_VALUE = \"Number of Samples\"\n  NUM_SUB_PACKAGES_FIELD_VALUE = \"Number of Sub Packages\"\n  UNIT_NAME_FIELD_VALUE = \"Unit Name\"\n  COMPONENTS_FIELD_VALUE = \"Components\"\n\n  ##########################################\n  # TERMINOLOGY\n  ##########################################\n  \n  # areas\n  PRE_PCR = \"pre-PCR\"\n  POST_PCR = \"post-PCR\"\n\n  # kit samples\n  CELL_LYSATE = \"cell lysate\" # what to call the input samples (cell lysates)\n  PCR_SAMPLE = \"PCR sample\" # what to call the tubes for the PCR protocol\n  LIGATION_SAMPLE = \"ligation sample\"\n\n  # equipment\n  THERMOCYCLER = \"thermocycler\" # what to call the thermocycler\n  CENTRIFUGE_PRE = \"centrifuge 1 (in the #{PRE_PCR} area)\"\n  CENTRIFUGE_POST = \"centrifuge 2 (in the #{POST_PCR} area)\"\n  PCR_RACK_PRE = \"PCR rack 1 (in the #{PRE_PCR} area)\" # what to call the racks the PCR tubes go in\n  PCR_RACK_POST = \"PCR rack 2 (in the #{POST_PCR} area)\" # what to call the racks the PCR tubes go in\n  PHOTOCOPIER = \"scanner\"\n  BASIC_MATERIALS_PRE = [\n      \"200uL pipette and filtered tips\",\n      \"20uL pipette and filtered tips\",\n      \"a spray bottle of 10% v/v bleach\",\n      \"a spray bottle of 70% v/v ethanol\",\n      \"a timer\",\n      \"latex gloves\"\n  ]\n  BASIC_MATERIALS_POST = [\n      \"200uL pipette and filtered tips\",\n      \"20uL pipette and filtered tips\",\n      \"a spray bottle of 10% v/v bleach\",\n      \"a spray bottle of 70% v/v ethanol\",\n      \"a timer\",\n      \"latex gloves\"\n  ]\n  TRASH_PRE = \"trash 1 (in the #{PRE_PCR} area)\"\n  TRASH_POST = \"trash 2 (in the #{POST_PCR} area)\"\n  WASTE_PRE = \"biohazard waste 1 (red bag in the #{PRE_PCR} area)\"\n  WASTE_POST = \"biohazard waste 2 (red bag in the #{POST_PCR} area)\"\n  BENCH_PRE = \"bench 1 (in the #{PRE_PCR} area)\"\n  BENCH_POST = \"bench 2 (in the #{POST_PCR} area)\"\n  PACKAGE_PRE = \"package (#{PRE_PCR})\"\n  PACKAGE_POST = \"package (#{POST_PCR})\"\n  FRIDGE_PRE = \"fridge 1 (in the #{PRE_PCR} area)\"\n  FRIDGE_POST = \"fridge 2 (in the #{POST_PCR} area)\"\n  P20_PRE = \"#{PRE_PCR} P20\"\n  P20_POST = \"#{POST_PCR} P20\"\n  P200_PRE = \"#{PRE_PCR} P200\"\n  P200_POST = \"#{POST_PCR} P200\"\n  P1000_PRE = \"#{PRE_PCR} P1000\"\n  P1000_POST = \"#{POST_PCR} P1000\"\n  WIPE_PRE = \"KimWipe (from the #{PRE_PCR} area)\"\n  WIPE_POST = \"KimWipe (from the #{POST_PCR} area)\"\n\n  # verbs\n  CENTRIFUGE_VERB = \"centrifuge\" # or spin?\n\n  PCR_CYCLE = \"OSPCR\"\n  LIG_CYCLE = \"OSLIG\"\n  STOP_CYCLE = \"OSSTOP\"\n  \n  def map_temporary_from_input(input, outputs, keys)\n    outputs = [outputs].flatten\n    keys = [keys].flatten\n    operations.each do |op|\n      input_item = op.input(input).item\n      outputs.each do |out|\n        keys.each do |k|\n          op.output(out).item.associate LOT, input_item.get(k)\n        end\n      end\n    end\n  end\n\n  def explicit_retrieve\n    operations.retrieve interactive: false\n\n    show do\n      title \"Retrieve the following items:\"\n\n      t = Table.new\n      input_items = operations.map {|op| op.inputs.map {|i| i.item}}.flatten\n      t.add_column(\"ID\", input_items.map {|i| i.id})\n      t.add_column(\"Type\", input_items.map {|i| i.object_type.name})\n      t.add_column(\"Location\", input_items.map {|i| i.location})\n      table t\n    end\n  end\nend\n"}},{"library":{"name":"OLAGraphics","category":"OLASimple","code_source":"# require_relative 'graphics'\nneeds \"OLASimple/SVGGraphics\"\nmodule OLAGraphics\n  include Graphics\n  include Graphics::MyGraphics\n\n  @@colors = [\"red\", \"yellow\", \"green\", \"blue\", \"purple\", \"gray\"]\n\n  def self.set_tube_colors(new_colors)\n    @@colrs = new_colors\n  end\n\n\n  #####################################\n  # BASICS\n  #####################################\n\n  def get_style\n    \u003c\u003cEOF\n      /* \u003c![CDATA[ */\n      \n      #svg .yellow path {\n          fill: #f7f9c2;\n      }\n      \n      #svg .white rect {\n          fill: #ffffff;\n      }\n      \n      #svg .gray path {\n          fill: #d4d4d4;\n      }\n      \n      #svg .blue path {\n          fill: #bdf8f9;\n      }\n      \n      #svg .red path {\n          fill: #ffc4c4;\n      }\n      \n      #svg .green path {\n          fill: #c4f9c2;\n      }\n      \n      #svg .purple path {\n          fill: #f1e0fc;\n      }\n\n      #svg .hidden {\n        opacity: 0.3;\n      }\n\n      #svg .yellowstrip rect {\n          fill: #f7f9c2;\n      }\n      \n      #svg .bluestrip rect {\n          fill: #bdf8f9;\n      }\n      \n      #svg .whitestrip rect {\n          fill: #ffffff;\n      }\n      \n      #svg .redstrip rect {\n          fill: #ffc4c4;\n      }\n      \n      #svg .graystrip rect {\n          fill: #d4d4d4;\n      }\n      \n      #svg .greenstrip rect {\n          fill: #c4f9c2;\n      }\n      \n      #svg .purplestrip rect {\n          fill: #f1e0fc;\n      }\n\n      #svg .redfluid path {\n        fill: #ff7c66;\n      }\n      \n      #svg .brownfluid path {\n        fill: #8B4513;\n      }\n\n      #svg .pinkfluid path {\n        fill: #ff8eec;\n      }\n      \n      #svg .palefluid path {\n          fill: #F2F5D1;\n      }\n      /* ]]\u003e */\nEOF\n  end\n\n  def display_svg(element, scale = 1)\n    element.style!(self.get_style)\n    element.svg(element.boundx, element.boundy, scale).to_str\n  end\n\n  # two labels on top of each other\n  def two_labels(text1, text2)\n    label1 = label(text1, \"font-size\".to_sym =\u003e 25)\n    label2 = label(text2, \"font-size\".to_sym =\u003e 25)\n    label2.align!('center-top')\n    label2.align_with(label1, 'center-bottom')\n    label2.translate!(0, 12)\n    SVGElement.new(children: [label1, label2], boundx: label1.boundx, boundy: label1.boundy * 2)\n  end\n\n  # make a tube label\n  def tube_label(kit, unit, component, sample)\n    self.two_labels(\"#{unit}#{component}\", \"#{sample}\")\n  end\n\n  def make_arrow(from, to, tlabel = nil, blabel = nil, tfontsize = 25, bfontsize = 25)\n    # make right arrow\n    top_label = label(tlabel, \"font-size\".to_sym =\u003e tfontsize)\n    bottom_label = label(blabel, \"font-size\".to_sym =\u003e bfontsize)\n    arrow = rarrow.scale(0.75)\n    arrow.align!('center-right')\n    arrow.align_with(to, 'center-left')\n    v1 = from.get_abs_anchor('center-right') - from.abs_anchor_vector\n    v2 = to.get_abs_anchor('center-left') - to.abs_anchor_vector\n    m = (v1 + v2) / 2.0\n    line = Line.new(*v1, *v2, 'black', 3)\n    unless top_label.nil?\n      top_label.translate!(*m)\n      top_label.align!('center-bottom').translate!(0, -10)\n    end\n    unless bottom_label.nil?\n      bottom_label.translate!(*m)\n      puts bottom_label\n      bottom_label.align!('center-top').translate!(0, 10)\n    end\n    myarrow = SVGElement.new(children: [line, arrow, bottom_label, top_label].compact)\n  end\n\n  def make_transfer(from, to, spacing, top_label, bottom_label)\n    to.align_with(from, 'center-right').align!('center-left')\n    to.translate!(spacing)\n    arrow = make_arrow(from, to, top_label, bottom_label)\n    elements = [arrow, from, to]\n    puts elements.map {|e| Vector[e.x, e.y] + e.get_abs_anchor('center-right')}\n    max_x = elements.map {|e| (Vector[e.x, e.y] + e.get_abs_anchor('center-right'))[0]}.max\n    max_y = elements.map {|e| (Vector[e.x, e.y] + e.get_abs_anchor('center-bottom'))[1]}.max\n    svg = SVGElement.new(\n        children: elements,\n        boundx: 700,\n        boundy: 300,\n        )\n    svg.translate!(20)\n  end\n\n  def make_tube(tube, bottom_label, middle_label, fluid = nil, cropped_for_closed_tube = false, fluidclass: nil)\n    bottom_label = bottom_label.join(\"\\n\") if bottom_label.is_a?(Array)\n    middle_label = middle_label.join(\"\\n\") if middle_label.is_a?(Array)\n    img = SVGElement.new(boundx: tube.boundx, boundy: tube.boundy)\n    tube_group = tube\n    bottom_labels = bottom_label.split(\"\\n\")\n    middle_labels = middle_label.split(\"\\n\")\n\n    img.add_child(tube)\n    fluidImage = nil\n    if fluid == \"small\"\n      fluidImage = fluid_small\n    elsif fluid == \"medium\"\n      fluidImage = fluid_medium\n    elsif fluid == \"large\"\n      fluidImage = fluid_large\n    elsif fluid == \"powder\"\n      fluidImage = powder\n    end\n    puts fluid\n    fluidImage.new_class!(fluidclass) unless fluidImage.nil? or fluidclass.nil?\n    img.add_child(fluidImage) unless fluidImage.nil?\n    puts fluid\n    if bottom_label != \"\"\n      bl = nil\n      if bottom_labels.length == 2\n        bl = two_labels(*bottom_labels)\n      else\n        label = label(bottom_label, \"font-size\".to_sym =\u003e 25)\n        bl = label\n      end\n      bl.align!('center-top')\n      bl.align_with(tube, 'center-bottom')\n      bl.translate!(-5 * tube.xscale, 5 * tube.yscale)\n      tube.boundy = tube.boundy + bl.boundy\n      img.add_child(bl)\n    end\n\n    if middle_label != \"\"\n      ml = nil\n      if middle_labels.length == 2\n        ml = two_labels(*middle_labels)\n      else\n        ml = label(middle_label, \"font-size\".to_sym =\u003e 25)\n      end\n      ml.align!('center-center')\n      ml.align_with(tube, 'center-bottom')\n      ml.translate!(-9 * tube.xscale, -110 * tube.yscale)\n      img.add_child(ml)\n    end\n\n\n    img.boundx = tube.boundx\n    img.boundy = tube.boundy\n    if cropped_for_closed_tube\n      shift = 70\n      img.boundy = img.boundy - shift\n      img.group_children.translate!(0, -shift)\n    end\n    img.translate!(10)\n  end\n\n  #####################################\n  # LIGATIONS\n  #####################################\n\n  def stripwell(kit, unit, components, sample, open_tubes, apply_classes, hide, spacing)\n    open_tubes = open_tubes || []\n    hide = hide || []\n    apply_classes = apply_classes || []\n    num = components.length\n    grid = SVGGrid.new(num, 1, spacing, opentube.boundy)\n    grid.each_pos do |r, c|\n\n      # add label\n      tube_label = [\"#{unit}#{components[r]}\", \"#{sample}\"]\n      tube_type = closedtube\n      if open_tubes.include?(r)\n        tube_type = opentube\n      end\n      tube = make_tube(tube_type,\n                       \"\",\n                       tube_label,\n                       nil,\n                       false)\n      tube.new_class!(apply_classes[r])\n      if hide.include?(r)\n        tube = tube.g(classname: 'hidden')\n      end\n      grid.add(tube, r, c)\n    end\n    grid\n  end\n\n  def display_ligation_tubes(kit, unit, components, sample, colors, open_tubes = nil, hide = nil, spacing = 70)\n    \n    mystripwell = stripwell(kit, unit, components, sample, open_tubes, colors, hide, spacing).scale!(0.75)\n    myimage = SVGElement.new(boundx: 500, boundy: 190)\n    myimage.add_child(mystripwell)\n  end\n\n  def highlight_ligation_tube(i, kit, unit, components, sample, colors)\n    ligation_tubes = self.display_ligation_tubes(\n        kit, unit, components, sample, colors, [i], (0..components.length - 1).to_a.reject {|x| x == i})\n    ligation_tubes\n  end\n\n  def transfer_to_ligation_tubes_with_highlight(from, i, kit, unit, components, sample, colors, vol, bottom_label = nil)\n    bottom_label = bottom_label || \"\"\n    ligation_tubes = self.highlight_ligation_tube(i, kit, unit, components, sample, colors)\n    ligation_tubes.align_with(from, 'center-right').align!('center-left')\n    ligation_label = label(\"ligation tubes\", \"font-size\".to_sym =\u003e 25)\n    # ligation_label.align_with(ligation_tubes, 'center-bottom').align!('center-top')\n    svg = self.make_transfer(from, ligation_tubes, 200, \"#{vol}uL\", bottom_label)\n    svg.translate!(20)\n    svg.boundy = svg.boundy - 20\n    svg.boundx = 700\n    svg.boundy = 295\n    svg\n  end\n\n  #####################################\n  # DETECTION\n  #####################################\n\n  def display_strip_panel(kit, unit, components, sample, colors)\n    def panel kit, unit, components, sample, apply_classes\n      apply_classes = apply_classes || []\n      num = components.length\n      strip = make_strip(nil, \"\")\n      grid = SVGGrid.new(num, 1, 90, strip.boundy)\n      grid.each_pos do |r, c|\n\n        # add label\n        strip_label = self.tube_label(kit, unit, components[r], sample).scale(0.8)\n        strip = make_strip(strip_label, apply_classes[r] + \"strip\")\n        grid.add(strip, r, c)\n      end\n      grid.scale!(0.75)\n    end\n    \n    mypanel = panel(kit, unit, components, sample, colors)\n    mypanel.boundx = 600\n    mypanel\n  end\n\n  def display_panel_and_tubes(kit, panel_unit, tube_unit, components, sample, colors)\n    tubes = display_ligation_tubes(kit, tube_unit, components, sample, colors)\n    panel = display_strip_panel(kit, panel_unit, components, sample, colors)\n    tubes.align_with(panel, 'center-bottom')\n    tubes.align!('center-top')\n    tubes.translate!(0, -50)\n    img = SVGElement.new(children: [tubes, panel], boundy: 330, boundx: panel.boundx)\n  end\n\n  def make_strip mylabel, classname\n    mystrip = SVGElement.new(boundx: 83.1, boundy: 247.45)\n    mystrip.add_child(self.strip)\n    mystrip.add_child(self.striplabel.new_class(classname))\n    # mylabel = label(\"Strip\", \"font-size\".to_sym=\u003e20)\n    unless mylabel.nil?\n      mylabel.align_with(mystrip, 'center-top')\n      mylabel.align!('center-center')\n      mylabel.translate!(0, 20)\n      mystrip.add_child(mylabel)\n    end\n    mystrip\n  end\n\n  def detection_strip_diagram\n    img = SVGElement.new(boundx: 270, boundy: 270)\n    img.add_child(\u003c\u003cEOF\n     \u003cg id=\"Strip\"\u003e\n\t\u003cg\u003e\n\t\t\u003crect x=\"4.75\" fill=\"#E6E7E8\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"78.346\" height=\"242.948\"/\u003e\n\t\t\u003cline fill=\"#E6E7E8\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"0\" y1=\"247.448\" x2=\"4.75\" y2=\"242.948\"/\u003e\n\t\t\u003cpolygon fill=\"#E6E7E8\" stroke=\"#000000\" stroke-miterlimit=\"10\" points=\"-0.067,4.777 4.75,0.001 4.75,242.948 0,247.448 \t\t\"/\u003e\n\t\t\u003cpolygon fill=\"#E6E7E8\" stroke=\"#000000\" stroke-miterlimit=\"10\" points=\"74.917,247.448 0,247.448 4.75,242.948 83.096,242.948 \n\t\t\t\t\t\"/\u003e\n\t\u003c/g\u003e\n\t\u003cg\u003e\n\t\t\u003crect x=\"19.583\" y=\"49.433\" fill=\"#E6E7E8\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"46.667\" height=\"80\"/\u003e\n\t\t\u003crect x=\"27.083\" y=\"57.433\" fill=\"#FFFFFF\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"31.667\" height=\"64\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"27.083\" y1=\"121.433\" x2=\"19.583\" y2=\"129.433\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"58.75\" y1=\"121.433\" x2=\"66.25\" y2=\"129.433\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"58.75\" y1=\"57.433\" x2=\"66.25\" y2=\"49.433\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"27.083\" y1=\"57.433\" x2=\"19.583\" y2=\"49.433\"/\u003e\n\t\u003c/g\u003e\n\t\u003cg\u003e\n\t\t\u003cpath fill=\"#E6E7E8\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M57.524,216.515c0,4.385-3.693,7.938-8.249,7.938H36.557\n\t\t\tc-4.556,0-8.249-3.554-8.249-7.938v-22.164c0-4.385,3.693-7.939,8.249-7.939h12.718c4.556,0,8.249,3.554,8.249,7.939V216.515z\"/\u003e\n\t\t\u003cpath fill=\"#FFFFFF\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M52.917,213.019c0,3.002-2.528,5.435-5.647,5.435h-8.706\n\t\t\tc-3.119,0-5.647-2.433-5.647-5.435v-15.172c0-3.001,2.528-5.435,5.647-5.435h8.706c3.119,0,5.647,2.433,5.647,5.435V213.019z\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"34.01\" y1=\"216.224\" x2=\"30.27\" y2=\"221.647\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"51.823\" y1=\"216.224\" x2=\"55.562\" y2=\"221.647\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"51.823\" y1=\"194.642\" x2=\"55.023\" y2=\"188.663\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"34.01\" y1=\"194.195\" x2=\"30.27\" y2=\"189.666\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"32.917\" y1=\"205.433\" x2=\"28.308\" y2=\"205.433\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"52.917\" y1=\"205.433\" x2=\"57.524\" y2=\"205.433\"/\u003e\n\t\u003c/g\u003e\n\u003c/g\u003e\n\u003cg id=\"StripLabel\"\u003e\n\t\u003crect x=\"4.75\" fill=\"#ED1C24\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"78.346\" height=\"46.433\"/\u003e\n\u003c/g\u003e\n\u003cpolygon fill=\"#BBC9E7\" stroke=\"#000000\" stroke-miterlimit=\"10\" points=\"43.923,198.542 48.016,201.414 166.567,59.148 \n\t141.463,41.534 \"/\u003e\n\u003ctext transform=\"matrix(1 0 0 1 -60.75 216.2236)\" font-family=\"'MyriadPro-Regular'\" font-size=\"20\"\u003ePort\u003c/text\u003e\n\u003ctext transform=\"matrix(1 0 0 1 -87.2627 91.1001)\"\u003e\u003ctspan x=\"0\" y=\"0\" font-family=\"'MyriadPro-Regular'\" font-size=\"20\"\u003eReading\u003c/tspan\u003e\u003ctspan x=\"0\" y=\"24\" font-family=\"'MyriadPro-Regular'\" font-size=\"20\"\u003eWindow\u003c/tspan\u003e\u003c/text\u003e\n\u003cline fill=\"none\" stroke=\"#000000\" stroke-width=\"4\" stroke-miterlimit=\"10\" x1=\"-11.417\" y1=\"95.1\" x2=\"32.917\" y2=\"94.1\"/\u003e\n\u003cline fill=\"none\" stroke=\"#000000\" stroke-width=\"4\" stroke-miterlimit=\"10\" x1=\"-17.417\" y1=\"209.401\" x2=\"26.917\" y2=\"208.401\"/\u003e\nEOF\n    )\n    img.translate!(100)\n    return img\n  end\n\n  def negative_selection_diagram\n    img = SVGElement.new(boundx: 600, boundy: 262)\n    img.add_child(\u003c\u003cEOF\n\u003cg id=\"SingleTubes_3_\"\u003e\n\t\u003cg id=\"ClosedLid_3_\"\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M363.205,46.889c22.801,0,22.801,18.312,0,18.312c0-1.189,0-2.38,0-3.57c13.912,0,13.912-11.173,0-11.173\n\t\t\t\tC363.205,49.268,363.205,48.078,363.205,46.889z\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M363.205,46.889c22.801,0,22.801,18.312,0,18.312\n\t\t\t\tc0-1.189,0-2.38,0-3.57c13.912,0,13.912-11.173,0-11.173C363.205,49.268,363.205,48.078,363.205,46.889z\"/\u003e\n\t\t\u003c/g\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M317.727,67.92c0,1.1,0.9,2,2,2h37.25c1.1,0,2-0.9,2-2v-0.688c0-1.1-0.535-2-1.188-2\n\t\t\t\tc-0.654,0-1.188-0.9-1.188-2v-8.938c0-1.1-0.9-2-2-2h-32.5c-1.1,0-2,0.9-2,2v8.938c0,1.1-0.534,2-1.188,2s-1.188,0.9-1.188,2\n\t\t\t\tV67.92z\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M317.727,67.92c0,1.1,0.9,2,2,2h37.25c1.1,0,2-0.9,2-2v-0.688\n\t\t\t\tc0-1.1-0.535-2-1.188-2c-0.654,0-1.188-0.9-1.188-2v-8.938c0-1.1-0.9-2-2-2h-32.5c-1.1,0-2,0.9-2,2v8.938c0,1.1-0.534,2-1.188,2\n\t\t\t\ts-1.188,0.9-1.188,2V67.92z\"/\u003e\n\t\t\u003c/g\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M308.352,48.026c-0.55-0.952-0.1-1.731,1-1.731h55.473c1.1,0,2.311,0.845,2.689,1.877l1.146,3.121\n\t\t\t\tc0.381,1.032-0.209,1.877-1.309,1.877h-54.028c-1.101,0-2.45-0.779-3.001-1.731L308.352,48.026z\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M308.352,48.026c-0.55-0.952-0.1-1.731,1-1.731h55.473\n\t\t\t\tc1.1,0,2.311,0.845,2.689,1.877l1.146,3.121c0.381,1.032-0.209,1.877-1.309,1.877h-54.028c-1.101,0-2.45-0.779-3.001-1.731\n\t\t\t\tL308.352,48.026z\"/\u003e\n\t\t\u003c/g\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"380.16\" y1=\"58.514\" x2=\"381.305\" y2=\"58.514\"/\u003e\n\t\u003c/g\u003e\n\t\u003cg id=\"Tube_3_\"\u003e\n\t\t\u003cpath fill=\"#F7FCFE\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M312.102,65.873v45.309l14.998,90.066\n\t\t\tc0,4.35,5.037,7.875,11.25,7.875c6.215,0,11.25-3.525,11.25-7.875l15-90.066V65.873H312.102z\"/\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M369.35,61.873c0,2.199-1.799,4-4,4h-54c-2.199,0-4-1.801-4-4v-1.875c0-2.201,1.801-4,4-4h54\n\t\t\t\tc2.201,0,4,1.799,4,4V61.873z\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M369.35,61.873c0,2.199-1.799,4-4,4h-54c-2.199,0-4-1.801-4-4\n\t\t\t\tv-1.875c0-2.201,1.801-4,4-4h54c2.201,0,4,1.799,4,4V61.873z\"/\u003e\n\t\t\u003c/g\u003e\n\t\u003c/g\u003e\n\u003c/g\u003e\n\u003cg id=\"SingleTubes_1_\"\u003e\n\t\u003cg id=\"ClosedLid_1_\"\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M175.96,48.821c22.801,0,22.801,18.312,0,18.312c0-1.189,0-2.38,0-3.57c13.912,0,13.912-11.173,0-11.173\n\t\t\t\tC175.96,51.2,175.96,50.011,175.96,48.821z\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M175.96,48.821c22.801,0,22.801,18.312,0,18.312\n\t\t\t\tc0-1.189,0-2.38,0-3.57c13.912,0,13.912-11.173,0-11.173C175.96,51.2,175.96,50.011,175.96,48.821z\"/\u003e\n\t\t\u003c/g\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M130.481,69.853c0,1.1,0.9,2,2,2h37.25c1.1,0,2-0.9,2-2v-0.688c0-1.1-0.535-2-1.188-2\n\t\t\t\tc-0.654,0-1.188-0.9-1.188-2v-8.938c0-1.1-0.9-2-2-2h-32.5c-1.1,0-2,0.9-2,2v8.938c0,1.1-0.534,2-1.188,2s-1.188,0.9-1.188,2\n\t\t\t\tV69.853z\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M130.481,69.853c0,1.1,0.9,2,2,2h37.25c1.1,0,2-0.9,2-2v-0.688\n\t\t\t\tc0-1.1-0.535-2-1.188-2c-0.654,0-1.188-0.9-1.188-2v-8.938c0-1.1-0.9-2-2-2h-32.5c-1.1,0-2,0.9-2,2v8.938c0,1.1-0.534,2-1.188,2\n\t\t\t\ts-1.188,0.9-1.188,2V69.853z\"/\u003e\n\t\t\u003c/g\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M121.106,49.959c-0.55-0.952-0.1-1.731,1-1.731h55.473c1.1,0,2.311,0.845,2.689,1.877l1.146,3.121\n\t\t\t\tc0.381,1.032-0.209,1.877-1.309,1.877h-54.028c-1.101,0-2.45-0.779-3.001-1.731L121.106,49.959z\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M121.106,49.959c-0.55-0.952-0.1-1.731,1-1.731h55.473\n\t\t\t\tc1.1,0,2.311,0.845,2.689,1.877l1.146,3.121c0.381,1.032-0.209,1.877-1.309,1.877h-54.028c-1.101,0-2.45-0.779-3.001-1.731\n\t\t\t\tL121.106,49.959z\"/\u003e\n\t\t\u003c/g\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"192.915\" y1=\"60.446\" x2=\"194.06\" y2=\"60.446\"/\u003e\n\t\u003c/g\u003e\n\t\u003cg id=\"Tube_1_\"\u003e\n\t\t\u003cpath fill=\"#F7FCFE\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M124.856,67.806v45.309l14.998,90.066\n\t\t\tc0,4.35,5.037,7.875,11.25,7.875c6.215,0,11.25-3.525,11.25-7.875l15-90.066V67.806H124.856z\"/\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M182.104,63.806c0,2.2-1.8,4-4,4h-54c-2.2,0-4-1.8-4-4v-1.875c0-2.2,1.8-4,4-4h54c2.2,0,4,1.8,4,4V63.806\n\t\t\t\tz\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M182.104,63.806c0,2.2-1.8,4-4,4h-54c-2.2,0-4-1.8-4-4v-1.875\n\t\t\t\tc0-2.2,1.8-4,4-4h54c2.2,0,4,1.8,4,4V63.806z\"/\u003e\n\t\t\u003c/g\u003e\n\t\u003c/g\u003e\n\u003c/g\u003e\n\u003cg id=\"SingleTubes_2_\"\u003e\n\t\u003cg id=\"ClosedLid_2_\"\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M272.545,47.965c22.801,0,22.801,18.312,0,18.312c0-1.189,0-2.38,0-3.57c13.912,0,13.912-11.173,0-11.173\n\t\t\t\tC272.545,50.344,272.545,49.154,272.545,47.965z\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M272.545,47.965c22.801,0,22.801,18.312,0,18.312\n\t\t\t\tc0-1.189,0-2.38,0-3.57c13.912,0,13.912-11.173,0-11.173C272.545,50.344,272.545,49.154,272.545,47.965z\"/\u003e\n\t\t\u003c/g\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M227.066,68.996c0,1.1,0.9,2,2,2h37.25c1.1,0,2-0.9,2-2v-0.688c0-1.101-0.534-2-1.188-2\n\t\t\t\ts-1.188-0.9-1.188-2v-8.938c0-1.1-0.9-2-2-2h-32.5c-1.1,0-2,0.9-2,2v8.938c0,1.1-0.534,2-1.188,2s-1.188,0.899-1.188,2V68.996z\"\n\t\t\t\t/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M227.066,68.996c0,1.1,0.9,2,2,2h37.25c1.1,0,2-0.9,2-2v-0.688\n\t\t\t\tc0-1.101-0.534-2-1.188-2s-1.188-0.9-1.188-2v-8.938c0-1.1-0.9-2-2-2h-32.5c-1.1,0-2,0.9-2,2v8.938c0,1.1-0.534,2-1.188,2\n\t\t\t\ts-1.188,0.899-1.188,2V68.996z\"/\u003e\n\t\t\u003c/g\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M217.691,49.103c-0.55-0.953-0.1-1.732,1-1.732h55.473c1.1,0,2.311,0.845,2.69,1.877l1.146,3.121\n\t\t\t\tc0.38,1.032-0.21,1.877-1.31,1.877h-54.028c-1.1,0-2.45-0.779-3-1.732L217.691,49.103z\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M217.691,49.103c-0.55-0.953-0.1-1.732,1-1.732h55.473\n\t\t\t\tc1.1,0,2.311,0.845,2.69,1.877l1.146,3.121c0.38,1.032-0.21,1.877-1.31,1.877h-54.028c-1.1,0-2.45-0.779-3-1.732L217.691,49.103z\n\t\t\t\t\"/\u003e\n\t\t\u003c/g\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"289.5\" y1=\"59.59\" x2=\"290.645\" y2=\"59.59\"/\u003e\n\t\u003c/g\u003e\n\t\u003cg id=\"Tube_2_\"\u003e\n\t\t\u003cpath fill=\"#F7FCFE\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M221.441,66.949v45.309l14.998,90.066\n\t\t\tc0,4.35,5.037,7.875,11.25,7.875c6.215,0,11.25-3.525,11.25-7.875l15-90.066V66.949H221.441z\"/\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M278.689,62.949c0,2.2-1.8,4-4,4h-54c-2.2,0-4-1.8-4-4v-1.875c0-2.2,1.8-4,4-4h54c2.2,0,4,1.8,4,4V62.949\n\t\t\t\tz\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M278.689,62.949c0,2.2-1.8,4-4,4h-54c-2.2,0-4-1.8-4-4v-1.875\n\t\t\t\tc0-2.2,1.8-4,4-4h54c2.2,0,4,1.8,4,4V62.949z\"/\u003e\n\t\t\u003c/g\u003e\n\t\u003c/g\u003e\n\u003c/g\u003e\n\u003cg id=\"SingleTubes_4_\"\u003e\n\t\u003cg id=\"ClosedLid_4_\"\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M459.754,47.131c22.801,0,22.801,18.312,0,18.312c0-1.189,0-2.38,0-3.57c13.912,0,13.912-11.173,0-11.173\n\t\t\t\tC459.754,49.51,459.754,48.32,459.754,47.131z\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M459.754,47.131c22.801,0,22.801,18.312,0,18.312\n\t\t\t\tc0-1.189,0-2.38,0-3.57c13.912,0,13.912-11.173,0-11.173C459.754,49.51,459.754,48.32,459.754,47.131z\"/\u003e\n\t\t\u003c/g\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M414.275,68.162c0,1.1,0.9,2,2,2h37.25c1.1,0,2-0.9,2-2v-0.688c0-1.1-0.535-2-1.188-2\n\t\t\t\tc-0.654,0-1.188-0.9-1.188-2v-8.938c0-1.1-0.9-2-2-2h-32.5c-1.1,0-2,0.9-2,2v8.938c0,1.1-0.534,2-1.188,2s-1.188,0.9-1.188,2\n\t\t\t\tV68.162z\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M414.275,68.162c0,1.1,0.9,2,2,2h37.25c1.1,0,2-0.9,2-2v-0.688\n\t\t\t\tc0-1.1-0.535-2-1.188-2c-0.654,0-1.188-0.9-1.188-2v-8.938c0-1.1-0.9-2-2-2h-32.5c-1.1,0-2,0.9-2,2v8.938c0,1.1-0.534,2-1.188,2\n\t\t\t\ts-1.188,0.9-1.188,2V68.162z\"/\u003e\n\t\t\u003c/g\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M404.9,48.269c-0.55-0.952-0.1-1.731,1-1.731h55.473c1.1,0,2.311,0.845,2.689,1.877l1.146,3.121\n\t\t\t\tc0.381,1.032-0.209,1.877-1.309,1.877h-54.028c-1.101,0-2.45-0.779-3.001-1.731L404.9,48.269z\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M404.9,48.269c-0.55-0.952-0.1-1.731,1-1.731h55.473\n\t\t\t\tc1.1,0,2.311,0.845,2.689,1.877l1.146,3.121c0.381,1.032-0.209,1.877-1.309,1.877h-54.028c-1.101,0-2.45-0.779-3.001-1.731\n\t\t\t\tL404.9,48.269z\"/\u003e\n\t\t\u003c/g\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"476.709\" y1=\"58.756\" x2=\"477.854\" y2=\"58.756\"/\u003e\n\t\u003c/g\u003e\n\t\u003cg id=\"Tube_4_\"\u003e\n\t\t\u003cpath fill=\"#F7FCFE\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M408.65,66.115v45.309l14.998,90.066\n\t\t\tc0,4.35,5.037,7.875,11.25,7.875c6.215,0,11.25-3.525,11.25-7.875l15-90.066V66.115H408.65z\"/\u003e\n\t\t\u003cg\u003e\n\t\t\t\u003cpath fill=\"#F7FCFE\" d=\"M465.898,62.115c0,2.199-1.799,4-4,4h-54c-2.199,0-4-1.801-4-4V60.24c0-2.201,1.801-4,4-4h54\n\t\t\t\tc2.201,0,4,1.799,4,4V62.115z\"/\u003e\n\t\t\t\u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M465.898,62.115c0,2.199-1.799,4-4,4h-54c-2.199,0-4-1.801-4-4\n\t\t\t\tV60.24c0-2.201,1.801-4,4-4h54c2.201,0,4,1.799,4,4V62.115z\"/\u003e\n\t\t\u003c/g\u003e\n\t\u003c/g\u003e\n\u003c/g\u003e\n\u003crect x=\"180.021\" y=\"67.951\" fill=\"#58595B\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"16.705\" height=\"143.104\"/\u003e\n\u003crect x=\"276.023\" y=\"68.36\" fill=\"#58595B\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"16.705\" height=\"143.104\"/\u003e\n\u003crect x=\"366.934\" y=\"66.539\" fill=\"#58595B\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"16.705\" height=\"143.104\"/\u003e\n\u003cg\u003e\n\t\u003cpath fill=\"#F2F5D1\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M151.104,211.465c6.215,0,11.25-3.525,11.25-7.875l15-90.066\n\t\tV92.904c-3.914-4.414-7.246-9.508-14.937-9.508c-13.567,0-13.567,15.856-27.136,15.856c-4.752,0-7.837-1.947-10.426-4.476v18.746\n\t\tl14.998,90.066C139.854,207.939,144.891,211.465,151.104,211.465z\"/\u003e\n\t\u003cpath id=\"largegoop_1_\" fill=\"#BE1E2D\" d=\"M176.233,99.027c-0.539-0.592-1.101-1.156-1.7-1.677\n\t\tc-2.18-1.891-4.767-3.295-7.818-4.106c-3.108-0.959-5.194-0.299-6.55,1.576c-1.355,1.877-1.983,4.971-2.176,8.881\n\t\tc-0.043,4.081,0.029,8.187,0.148,12.31c-0.371,3.683-0.492,7.357-0.467,11.022c0.897,18.184,3.846,37.165-0.056,56.177\n\t\tc-0.8,1.744-1.673,3.365-2.61,4.925c-3.899,3.502-12.119,3.583-12.802,9.137c-1.465,7.144,6.075,12.614,13.855,11.348\n\t\tc1.231-0.126,2.429-0.324,3.597-0.573c0.996-1.113,1.578-2.408,1.578-3.796l15-85.266V99.027z\"/\u003e\n\u003c/g\u003e\n\u003cg\u003e\n\t\u003cpath fill=\"#F2F5D1\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M338.349,210.596c6.215,0,11.25-3.525,11.25-7.875l15-90.066\n\t\tV92.035c-3.914-4.414-7.246-9.508-14.937-9.508c-13.567,0-13.567,15.856-27.136,15.856c-4.752,0-7.837-1.947-10.426-4.476v18.746\n\t\tl14.998,90.066C327.099,207.07,332.136,210.596,338.349,210.596z\"/\u003e\n\t\u003cpath id=\"smallgoop_1_\" fill=\"#BE1E2D\" d=\"M351.601,187.893c-0.48,0.29-0.853,0.667-1.167,1.104\n\t\tc-0.286,0.446-0.544,0.889-0.791,1.329c-0.345,0.425-0.624,0.832-0.864,1.229c-0.991,1.92-1.5,3.797-3.802,6.113\n\t\tc-0.326,0.24-0.664,0.473-1.014,0.702c-1.255,0.63-3.409,1.163-3.962,1.811c-0.864,0.87,0.737,0.984,2.856,0.351\n\t\tc2.816-0.787,5.354-1.938,7.215-3.107c0.564-0.939,0.878-1.972,0.878-3.055l1.118-6.713\n\t\tC351.903,187.729,351.745,187.806,351.601,187.893z\"/\u003e\n\u003c/g\u003e\n\u003cg\u003e\n\t\u003cpath fill=\"#F2F5D1\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M247.69,210.199c6.215,0,11.25-3.525,11.25-7.875l15-90.066\n\t\tV91.639c-3.914-4.414-7.246-9.508-14.937-9.508c-13.567,0-13.567,15.856-27.136,15.856c-4.752,0-7.837-1.947-10.426-4.476v18.746\n\t\tl14.998,90.066C236.44,206.674,241.478,210.199,247.69,210.199z\"/\u003e\n\t\u003cpath id=\"mediumgoop_1_\" fill=\"#BE1E2D\" d=\"M265.456,155.475c-1.722-0.177-2.978,0.252-3.904,1.138s-1.526,2.229-1.938,3.884\n\t\tc-0.338,1.716-0.611,3.433-0.859,5.154c-0.497,1.573-0.849,3.123-1.115,4.659c-0.877,7.564-0.631,15.315-4.343,23.576\n\t\tc-0.596,0.789-1.225,1.533-1.886,2.255c-2.521,1.753-7.274,2.385-8.095,4.764c-1.395,3.104,2.541,4.853,7.132,3.756\n\t\tc3.25-0.642,6.229-1.791,8.848-3.264c0.022-0.203,0.044-0.406,0.044-0.613l7.516-45.127\n\t\tC266.412,155.575,265.951,155.51,265.456,155.475z\"/\u003e\n\u003c/g\u003e\n\u003cg\u003e\n\t\u003cpath fill=\"#F2F5D1\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M434.899,209.771c6.215,0,11.25-3.525,11.25-7.875l15-90.066\n\t\tV91.211c-3.914-4.414-7.246-9.508-14.937-9.508c-13.567,0-13.567,15.856-27.136,15.856c-4.752,0-7.837-1.947-10.426-4.476v18.746\n\t\tl14.998,90.066C423.649,206.246,428.687,209.771,434.899,209.771z\"/\u003e\n\u003c/g\u003e\n\u003ctext transform=\"matrix(1 0 0 1 11.918 253.2422)\" font-family=\"'MyriadPro-Regular'\" font-size=\"25\"\u003eUnwanted Cells\u003c/text\u003e\n\u003ctext transform=\"matrix(1 0 0 1 12.8271 173.3662)\" font-family=\"'MyriadPro-Regular'\" font-size=\"25\"\u003eCD+ Cells\u003c/text\u003e\n\u003cg\u003e\n\t\u003cpolygon stroke=\"#000000\" stroke-miterlimit=\"10\" points=\"158.353,205.239 150.153,202.41 156.704,194.296 \t\"/\u003e\n\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-width=\"3\" stroke-miterlimit=\"10\" x1=\"154.61\" y1=\"202.672\" x2=\"147.199\" y2=\"232.312\"/\u003e\n\u003c/g\u003e\n\u003cg\u003e\n\t\u003cpolygon stroke=\"#000000\" stroke-miterlimit=\"10\" points=\"135.032,139.835 133.309,134.386 142.02,130.715 \t\"/\u003e\n\t\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-width=\"3\" stroke-miterlimit=\"10\" x1=\"135.147\" y1=\"136.361\" x2=\"110.832\" y2=\"156.343\"/\u003e\n\u003c/g\u003e\n\u003ctext transform=\"matrix(1 0 0 1 140.5879 38.501)\" font-family=\"'MyriadPro-Regular'\" font-size=\"41\"\u003e1\u003c/text\u003e\n\u003ctext transform=\"matrix(1 0 0 1 234.8652 36.8428)\" font-family=\"'MyriadPro-Regular'\" font-size=\"41\"\u003e2\u003c/text\u003e\n\u003ctext transform=\"matrix(1 0 0 1 326.0049 38.4541)\" font-family=\"'MyriadPro-Regular'\" font-size=\"41\"\u003e3\u003c/text\u003e\n\u003ctext transform=\"matrix(1 0 0 1 435.0049 38.4541)\" font-family=\"'MyriadPro-Regular'\" text-anchor=\"middle\" font-size=\"25\"\u003eCD4+/RBC\u003c/text\u003e\nEOF\n    )\n    img\n  end\nend"}},{"library":{"name":"OLAKitIDs","category":"OLASimple","code_source":"needs 'OLASimple/OLAConstants'\nmodule OLAKitIDs\n  \n  KIT_NUM_DIGITS = 3\n  SAMPLE_NUM_DIGITS = 3\n  BATCH_SIZE = OLAConstants::BATCH_SIZE\n  PROPOGATION_KEYS = [OLAConstants::KIT_KEY, OLAConstants::SAMPLE_KEY, OLAConstants::PATIENT_KEY] #which associations to propogate forward during an operation\n  \n  def extract_kit_number(id)\n    id.chars[-KIT_NUM_DIGITS, KIT_NUM_DIGITS].join.to_i if id.chars[-KIT_NUM_DIGITS, KIT_NUM_DIGITS]\n  end\n  \n  def extract_sample_number(id)\n    id.chars[-SAMPLE_NUM_DIGITS, SAMPLE_NUM_DIGITS].join.to_i if id.chars[-SAMPLE_NUM_DIGITS, SAMPLE_NUM_DIGITS]\n  end\n  \n  def sample_num_to_id(num)\n    num.to_s.rjust(SAMPLE_NUM_DIGITS, \"0\")\n  end\n  \n  def kit_num_to_id(num)\n    num.to_s.rjust(KIT_NUM_DIGITS, \"0\")\n  end\n  \n  # requires and returns integer ids\n  def kit_num_from_sample_num(sample_num)\n    ((sample_num - 1) / BATCH_SIZE).floor + 1\n  end\n  \n  # requires and returns integer ids\n  def sample_nums_from_kit_num(kit_num)\n    sample_nums = []\n    BATCH_SIZE.times do |i|\n      sample_nums \u003c\u003c kit_num * BATCH_SIZE - i\n    end\n    sample_nums.reverse\n  end\n  \n  def validate_samples(expected_sample_nums)\n    resp = show do\n      title \"Scan Incoming Samples\"\n      \n      note \"Scan in the IDs of all incoming samples in any order.\"\n      note \"There should not be more than #{expected_sample_nums.size} samples. \"\n      \n      expected_sample_nums.size.times do |i|\n        get \"text\", var: i.to_s.to_sym, label: \"\", default: \"\"\n      end\n    end\n    \n    expected_sample_nums.size.times do |i|\n      found = expected_sample_nums.delete(extract_sample_number(resp[i.to_s.to_sym])) if extract_sample_number(resp[i.to_s.to_sym])\n      return false unless found\n    end\n    return true\n  end\n  \n  def sample_validation_with_multiple_tries(kit_number)\n\n    5.times do\n      expected_sample_nums = sample_nums_from_kit_num(kit_number)\n      expected_sample_nums = expected_sample_nums[0,operations.size]\n      result = validate_samples(expected_sample_nums)\n      return true if result || debug\n      show do\n        title \"Wrong Samples\"\n        note \"Ensure that you have the correct samples before continuing\"\n        note \"You are processing kit \u003cb\u003e#{kit_num_to_id(kit_number)}\u003c/b\u003e\"\n        note \"Incoming samples should be numbered #{sample_nums_from_kit_num(kit_number).map { |s| sample_num_to_id(s) }.to_sentence}.\"\n        note \"On the next step you will retry scanning in the samples.\"\n      end\n    end\n    operations.each do |op|\n      op.error(:sample_problem, 'Incoming samples are wrong and could not be resolved')\n    end\n    raise \"Incoming samples are wrong and could not be resolved. Speak to a Lab manager.\"\n  end\n  \n  def record_technician_id\n    resp = show do\n      title 'Scan your technician ID'\n      note 'Scan or write in the technician ID on your badge'\n      get \"text\", var: :id, label: 'ID', default: \"\"\n    end\n    operations.each do |op|\n      op.associate(OLAConstants::TECH_KEY, resp[:id])\n    end\n  end\n  \n################################################################################\n####  ID PROPOGATION\n################################################################################\n\n  def populate_temporary_kit_info_from_input_associations(ops, input_name)\n    unless debug\n      # grab all data associations from inputs and place into temporary\n      populate_temporary_values_from_input_associations(ops, input_name, PROPOGATION_KEYS)\n    else\n      ops.each_with_index do |op, i|\n        op.temporary[OLAConstants::KIT_KEY] = kit_num_to_id(1)\n        op.temporary[OLAConstants::SAMPLE_KEY] = sample_num_to_id(i + 1)\n        op.temporary[OLAConstants::PATIENT_KEY] = rand(1..30).to_s\n      end\n    end\n  end\n\n  def populate_temporary_values_from_input_associations(ops, input_name, keys)\n    ops.each do |op|\n      from = op.input(input_name).item\n      from_das = DataAssociation.where(parent_id: from.id, parent_class: from.class.to_s, key: keys)\n      from_das.each do |da|\n        op.temporary[da.key.to_sym] = da.value\n      end\n    end\n  end\n\n  # Sends forward kit num, sample num, and patient id from the input item to the output item \n  # for all operations\n  def propogate_kit_info_forward(ops, input_name, output_name)\n    das = []\n    ops.each do |op|\n      new_das = propogate_information_lazy(\n          op.input(input_name).item,\n          op.output(output_name).item,\n          PROPOGATION_KEYS\n        )\n      das.concat(new_das)\n    end\n    DataAssociation.import das, on_duplicate_key_update: [:object]\n  end\n  \n  # propogate all data associations included in keys from one object to another\n  # returns data association list which much be imported in order to apply associations\n  # as in `DataAssociation.import das, on_duplicate_key_update: [:object]`\n  #\n  # Does not work to propogate uploads currently\n  def propogate_information_lazy(from, to, keys = [])\n    from_das = DataAssociation.where(parent_id: from.id, parent_class: from.class.to_s, key: keys)\n    from_das.map { |da| to.lazy_associate(da.key, da.value) }\n  end\n  \n  # populates op.temporary[:input_component] and :input_unit with the component from the input\n  def retrieve_input_components(ops)\n    ops.each do |op|\n      op.temporary[\"input_#{OLAConstants::COMPONENT_KEY}\".to_sym] = op.get(OLAConstants::COMPONENT_KEY)\n      op.temporary[\"input_#{OLAConstants::UNIT_KEY}\".to_sym] = op.get(OLAConstants::UNIT_KEY)\n    end\n  end\n  \n  # Assumes only one output item\n  def set_output_components(ops, component, unit)\n    items = ops.map { |op| op.outputs[0].item }\n    set_many_associations(items, OLAConstants::COMPONENT_KEY, component)\n    set_many_associations(items, OLAConstants::UNIT_KEY, unit)\n  end\n  \n  def set_many_associations(objects, key, value, upload = nil)\n    data_associations = []\n    objects.each do |o|\n      data_associations \u003c\u003c o.lazy_associate(key, value, upload)\n    end\n    DataAssociation.import data_associations, on_duplicate_key_update: [:object]\n  end\n  \n################################################################################\n####  WORKFLOW INITIATION\n################################################################################\n\n  # Assign sample aliases to items for all operations which share this kit\n  # will be re-done every time a new job is submitted for this kit so that\n  # the final sample id assignment is in correct sorted order when the next job is scheduled\n  #\n  # Assigns sample aliases in order of patient id. each operation must have op.temporary[:patient] set.\n  # Sample alias assignment is placed in op.temporary[:sample_num] for each op.\n  #\n  # requires that \"operations\" input only contains operations from a single kit\n  def assign_sample_aliases_from_kit_id(operations, kit_id)\n    operations = operations.sort_by { |op| op.temporary[OLAConstants::PATIENT_KEY] }\n    sample_nums = sample_nums_from_kit_num(extract_kit_number(kit_id))\n    operations.each_with_index do |op, i|\n      op.temporary[OLAConstants::SAMPLE_KEY] = sample_num_to_id(sample_nums[i])\n    end\n  end\n  \n  # get list of operations with the given kit id\n  # only retrieves operations which are done or running\n  # TODO speed up the data association queries\n  def get_kit_ops(kit_id, operation_type_id, lookback = 100)\n    operations = Operation.where({ operation_type_id: operation_type_id, status: [\"done\", \"running\"]}).last(lookback)\n    operations = operations.to_a.uniq\n    operations = operations.select { |op| op.get(OLAConstants::KIT_KEY).to_i == kit_id.to_i }\n    operations # return\n  end\n  \n  # must run DataAssociation.import on returned array in order to complete association\n  def associate_kit_information_lazy(obj, kit_num:, sample_num:, patient:)\n    das = []\n    das \u003c\u003c obj.lazy_associate(OLAConstants::KIT_KEY, kit_num)\n    das \u003c\u003c obj.lazy_associate(OLAConstants::SAMPLE_KEY, sample_num)\n    das \u003c\u003c obj.lazy_associate(OLAConstants::PATIENT_KEY, patient)\n  end\nend"}},{"library":{"name":"OLAKits","category":"OLASimple","code_source":"module OLAKits\n  def self.kenya_kit\n    {\n        \"name\" =\u003e \"kenya kit\",\n        \"sample prep\" =\u003e {\n            \"Unit Name\" =\u003e \"A\",\n            \"Components\" =\u003e {\n                \"magnetic beads\" =\u003e \"A\",\n                \"antibodies\" =\u003e \"B\",\n                \"1X PBS 1\" =\u003e \"C\",\n                \"RBC lysis buffer\" =\u003e \"D\",\n                \"1X PBS 2\" =\u003e \"E\",\n                \"CD4 lysis buffer\" =\u003e \"F\",\n                \"sample tube 1\" =\u003e \"G\",\n                \"sample tube 2\" =\u003e \"H\",\n                \"sample tube 3\" =\u003e \"J\",\n                \"sample tube 4\" =\u003e \"K\"\n            }\n        },\n\n        \"pcr\" =\u003e {\n            \"Unit Name\" =\u003e \"B\",\n            \"Components\" =\u003e {\n                \"sample tube\" =\u003e \"A\",\n                \"diluent A\" =\u003e \"B\"\n            },\n            \"PCR Rehydration Volume\" =\u003e 40,\n            \"Sample Volume\" =\u003e 10,\n            \"Number of Samples\" =\u003e 2,\n            \"Number of Sub Packages\" =\u003e 2,\n        },\n\n        \"ligation\" =\u003e {\n            \"Unit Name\" =\u003e \"C\",\n            \"Components\" =\u003e {\n                \"sample tubes\" =\u003e [\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"E\"\n                ],\n                \"diluent A\" =\u003e \"F\"\n            },\n            \"PCR to Ligation Mix Volume\" =\u003e 2.4,\n            \"Ligation Mix Rehydration Volume\" =\u003e 24,\n            \"Number of Samples\" =\u003e 2,\n            \"Number of Sub Packages\" =\u003e 2\n        },\n\n        \"detection\" =\u003e {\n            \"Unit Name\" =\u003e \"D\",\n            \"Components\" =\u003e {\n                \"strips\" =\u003e [\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"E\"\n                ],\n                \"stop\" =\u003e \"F\",\n                \"gold\" =\u003e \"G\",\n                \"diluent A\" =\u003e \"H\"\n            },\n            \"Number of Samples\" =\u003e 2,\n            \"Number of Sub Packages\" =\u003e 4,\n            \"Stop Rehydration Volume\" =\u003e 40,\n            \"Gold Rehydration Volume\" =\u003e 480,\n            \"Gold to Strip Volume\" =\u003e 40,\n            \"Sample to Strip Volume\" =\u003e 24,\n            \"Stop to Sample Volume\" =\u003e 2.4,\n        },\n\n        \"analysis\" =\u003e {\n            \"Components\" =\u003e {\n                \"strips\" =\u003e [\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"E\"\n                ],\n            },\n            \"Mutation Labels\" =\u003e [\n                \"K65R\",\n                \"K103N\",\n                \"Y181C\",\n                \"M184V\",\n                \"G190A\"\n            ],\n            \"Mutation Colors\" =\u003e [\"red\", \"yellow\", \"green\", \"blue\", \"purple\"]\n        }\n\n    }\n  end\n\n  def self.rt_pcr()\n    {\n        \"name\" =\u003e \"uw kit\",\n        \"sample prep\" =\u003e {\n            \"Unit Name\" =\u003e \"A\",\n            \"Components\" =\u003e {\n                \"sample tube 1\" =\u003e \"AA\",\n                \"sample tube 2\" =\u003e \"AB\",\n            }\n        },\n        \"extraction\" =\u003e \"todo\",\n        \"pcr\" =\u003e {\n            \"Unit Name\" =\u003e \"B\",\n            \"Components\" =\u003e {\n                \"sample tube\" =\u003e \"A\",\n                \"diluent A\" =\u003e \"B\"\n            },\n            \"PCR Rehydration Volume\" =\u003e 40,\n            \"Sample Volume\" =\u003e 10,\n            \"Number of Samples\" =\u003e 2,\n            \"Number of Sub Packages\" =\u003e 2,\n        },\n\n        \"ligation\" =\u003e {\n            \"Unit Name\" =\u003e \"C\",\n            \"Components\" =\u003e {\n                \"sample tubes\" =\u003e [\n                    \"1\",\n                    \"2\",\n                    \"3\",\n                    \"4\",\n                    \"5\",\n                    \"6\",\n                    \"7\"\n                ],\n                \"diluent A\" =\u003e \"G\"\n            },\n            \"PCR to Ligation Mix Volume\" =\u003e 1.2,\n            \"Ligation Mix Rehydration Volume\" =\u003e 24,\n            \"Number of Samples\" =\u003e 2,\n            \"Number of Sub Packages\" =\u003e 2\n        },\n\n        \"detection\" =\u003e {\n            \"Unit Name\" =\u003e \"D\",\n            \"Components\" =\u003e {\n                \"strips\" =\u003e [\n                    \"1\",\n                    \"2\",\n                    \"3\",\n                    \"4\",\n                    \"5\",\n                    \"6\",\n                    \"7\"\n                ],\n                \"stop\" =\u003e \"G\",\n                \"gold\" =\u003e \"H\",\n                \"diluent A\" =\u003e \"I\"\n            },\n            \"Number of Samples\" =\u003e 2,\n            \"Number of Sub Packages\" =\u003e 4,\n            \"Stop Rehydration Volume\" =\u003e 36,\n            \"Gold Rehydration Volume\" =\u003e 600,\n            \"Gold to Strip Volume\" =\u003e 40,\n            \"Sample to Strip Volume\" =\u003e 24,\n            \"Stop to Sample Volume\" =\u003e 2.4,\n            \"Sample Volume\" =\u003e 2.4,\n            \"Mutation Labels\" =\u003e [\n                \"K65R\",\n                \"K103N\",\n                \"V106M\",\n                \"Y181C\",\n                \"M184V\",\n                \"G190A\",\n                \"UNKNOWN\"\n            ],\n            \"Mutation Colors\" =\u003e [\"red\", \"green\",\"yellow\", \"blue\", \"purple\", \"white\", \"gray\"]\n\n        }\n\n    }\n  end\n\n\n\n  def self.uw_kit()\n    {\n        \"name\" =\u003e \"uw kit\",\n        \"sample prep\" =\u003e {\n            \"Unit Name\" =\u003e \"A\",\n            \"Components\" =\u003e {\n                \"sample tube 1\" =\u003e \"AA\",\n                \"sample tube 2\" =\u003e \"AB\",\n            }\n        },\n\n        \"pcr\" =\u003e {\n            \"Unit Name\" =\u003e \"B\",\n            \"Components\" =\u003e {\n                \"sample tube\" =\u003e \"A\",\n                \"diluent A\" =\u003e \"B\"\n            },\n            \"PCR Rehydration Volume\" =\u003e 40,\n            \"Sample Volume\" =\u003e 10,\n            \"Number of Samples\" =\u003e 2,\n            \"Number of Sub Packages\" =\u003e 2,\n        },\n\n        \"ligation\" =\u003e {\n            \"Unit Name\" =\u003e \"C\",\n            \"Components\" =\u003e {\n                \"sample tubes\" =\u003e [\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"E\",\n                    \"F\"\n                ],\n                \"diluent A\" =\u003e \"G\"\n            },\n            \"PCR to Ligation Mix Volume\" =\u003e 1.2,\n            \"Ligation Mix Rehydration Volume\" =\u003e 24,\n            \"Number of Samples\" =\u003e 2,\n            \"Number of Sub Packages\" =\u003e 2\n        },\n\n        \"detection\" =\u003e {\n            \"Unit Name\" =\u003e \"D\",\n            \"Components\" =\u003e {\n                \"strips\" =\u003e [\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"E\",\n                    \"F\"\n                ],\n                \"stop\" =\u003e \"G\",\n                \"gold\" =\u003e \"H\",\n                \"diluent A\" =\u003e \"I\"\n            },\n            \"Number of Samples\" =\u003e 2,\n            \"Number of Sub Packages\" =\u003e 4,\n            \"Stop Rehydration Volume\" =\u003e 36,\n            \"Gold Rehydration Volume\" =\u003e 600,\n            \"Gold to Strip Volume\" =\u003e 40,\n            \"Sample to Strip Volume\" =\u003e 24,\n            \"Stop to Sample Volume\" =\u003e 2.4,\n            \"Sample Volume\" =\u003e 2.4\n        },\n\n        \"analysis\" =\u003e {\n            \"Components\" =\u003e {\n                \"strips\" =\u003e [\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"E\",\n                    \"F\"\n                ],\n            },\n            \"Mutation Labels\" =\u003e [\n                \"K65R\",\n                \"K103N\",\n                \"V106M\",\n                \"Y181C\",\n                \"M184V\",\n                \"G190A\"\n            ],\n            \"Mutation Colors\" =\u003e [\"red\", \"yellow\", \"white\", \"green\", \"blue\", \"purple\"]\n        }\n\n    }\n  end\nend"}},{"library":{"name":"OLALib","category":"OLASimple","code_source":"# Library code here\n# category = \"Tissue Culture Libs\"\n# needs \"#{category}/TissueCulture\"\nneeds \"OLASimple/OLAConstants\"\nneeds \"OLASimple/OLAGraphics\"\nneeds \"OLASimple/NetworkRequests\"\n\nmodule TextExtension\n  include ActionView::Helpers::TagHelper\n\n  def bold\n    return content_tag(:b, \"#{self}\")\n  end\n\n  def ital\n    return content_tag(:i, \"#{self}\")\n  end\n\n  def strong\n    return content_tag(:strong, \"#{self}\")\n  end\n\n  def color(which_color)\n    return content_tag(:font, \"#{self}\", color: which_color)\n  end\n\n  def cap\n    remaining = \"\"\n    remaining = self[1..-1] if self.length \u003e 1\n    return self[0].capitalize + remaining\n  end\n\n  def quote\n    return \"\\\"#{self}\\\"\"\n  end\nend\n\nmodule RefExtension\n  include OLAConstants\n  # this requires :output_kit, :output_unit, :output_sample, and :pack_hash temporary values\n  # references require :kit, :unit, :component, and :sample keys\n\n  def sort_by \u0026block\n    super(\u0026block).extend(OperationList)\n  end\n\n  def component(name)\n    self.temporary[:pack_hash][COMPONENTS_FIELD_VALUE][name]\n  end\n\n  def input_component(name)\n    get_input_item_helper(name).get(COMPONENT_KEY)\n  end\n\n  def output_component(name)\n    self.get_output_item_helper(name).get(COMPONENT_KEY)\n  end\n\n  def ref(name, with_sample = false)\n    # returns the label for a temporary item by name\n    t = self.temporary\n    c = self.component(name)\n    kit = t[:output_kit]\n    unit = t[:output_unit]\n    # samp = t[:output_sample]\n    samp = \"\"\n    if with_sample\n      samp = t[:output_sample]\n    end\n    self.alias_helper(kit, unit, c, samp)\n  end\n\n  def tube_label(name, with_sample = false)\n    self.label_helper(*self.ref_tokens(name, with_sample))\n  end\n\n  def label_helper(k, u, c, s)\n    [\"#{u}#{c}\", \"#{s}\"]\n  end\n\n  def input_tube_label(name)\n    self.label_helper(*self.input_tokens(name))\n  end\n\n  def output_tube_label(name)\n    self.label_helper(*self.output_tokens(name))\n  end\n\n  # TOKENS\n  def ref_tokens(name, with_sample = false)\n    # return array for kit-unit and component-sample, usually for labeling purposes\n    t = self.temporary\n    c = self.component(name)\n    kit = t[:output_kit]\n    unit = t[:output_unit]\n    samp = \"\" #t[:output_sample]\n    if with_sample\n      samp = t[:output_sample]\n    end\n    [kit, unit, c, samp]\n  end\n\n  def ref_tokens_helper(item)\n    [item.get(KIT_KEY), item.get(UNIT_KEY), item.get(COMPONENT_KEY), item.get(SAMPLE_KEY)]\n  end\n\n  def input_tokens(name)\n    self.ref_tokens_helper(self.get_input_item_helper(name))\n  end\n\n  def output_tokens(name)\n    self.ref_tokens_helper(self.get_output_item_helper(name))\n  end\n\n  def alias_helper(kit, unit, component, sample)\n    # returns the label given kit, unit, comp and sample\n    if !sample.blank?\n      \"#{unit}#{component}-#{sample}\"\n    else\n      \"#{unit}#{component}\"\n    end\n  end\n\n  def ref_helper(item)\n    # returns the label for an item\n    self.alias_helper(*self.ref_tokens_helper(item))\n  end\n\n  def refs_helper(item)\n    # returns an array of labels for a collection\n    components = item.get(COMPONENT_KEY)\n    raise \"Components must be an array to use refs_helper\" unless components.is_a?(Array)\n    components.map do |c|\n      self.alias_helper(item.get(KIT_KEY), item.get(UNIT_KEY), c, item.get(SAMPLE_KEY))\n    end\n  end\n\n  def get_input_item_helper(name)\n    input = self.input(name)\n    raise \"Could not find input field_value #{name}\" if input.nil?\n    item = input(name).item\n    raise \"Input #{name} has no item\" if item.nil?\n    item\n  end\n\n  def get_output_item_helper(name)\n    output = self.output(name)\n    raise \"Could not find output field_value \\\"#{name}\\\"\" if output.nil?\n    item = output(name).item\n    raise \"Output \\\"#{name}\\\" has no item\" if item.nil?\n    item\n  end\n\n  def input_ref(name)\n    # return the label for an input\n    self.ref_helper(get_input_item_helper(name))\n  end\n\n  def input_ref_tokens(name)\n    # return the label for an input\n    self.ref_tokens_helper(get_input_item_helper(name))\n  end\n\n  def output_ref(name)\n    # return the label for an output\n    self.ref_helper(get_output_item_helper(name))\n  end\n\n  def output_ref_tokens(name)\n    # return the label for an input\n    self.ref_tokens_helper(get_output_item_helper(name))\n  end\n\n  def input_refs(name)\n    # return the array of labels for an input\n    self.refs_helper(get_input_item_helper(name))\n  end\n\n  def output_refs(name)\n    # return the array of labels for an output\n    self.refs_helper(get_output_item_helper(name))\n  end\n\n  def make_alias_from_pack_hash(output_item, package_name, from_item)\n    kit = self.temporary[:output_kit]\n    unit = self.temporary[:output_unit]\n    component = self.component(package_name)\n    sample = self.temporary[:output_sample]\n    patient = self.temporary[:patient]\n\n    raise \"Kit is nil\" if kit.nil?\n    raise \"Unit is nil\" if unit.nil?\n    raise \"Component is nil\" if component.nil?\n    raise \"Sample is nil\" if sample.nil?\n    raise \"Patient ID is nil\" if patient.nil?\n\n    output_item.associate(KIT_KEY, kit)\n    output_item.associate(UNIT_KEY, unit)\n    output_item.associate(COMPONENT_KEY, component)\n    output_item.associate(SAMPLE_KEY, sample)\n    output_item.associate(PATIENT_KEY, patient)\n    output_item.associate(ALIAS_KEY, self.ref_helper(output_item))\n    \n    # from associations\n    output_item.associate(:from, self.input(from_item).item.id)\n    output_item.associate(:fromref, self.input_ref(from_item))\n    output_item.associate(:from_pack, \"#{self.temporary[:input_unit]}#{self.temporary[:input_kit]}\")\n    output_item\n  end\n\n  def make_item_and_alias(name, package_name, from_item)\n    self.output(name).make\n    output_item = self.output(name).item\n    self.make_alias_from_pack_hash(output_item, package_name, from_item)\n  end\n\n  def make_collection_and_alias(name, package_name, from_item)\n    output_collection = self.output(name).make_collection\n    components = self.component(package_name)\n    components.each do |c|\n      output_collection.add_one(self.output(name).sample)\n    end\n    output_item = self.output(name).item\n    self.make_alias_from_pack_hash(output_item, package_name, from_item)\n  end\nend\n\nmodule OLALib\n  include OLAConstants\n  include NetworkRequests\n\n  String.send(:prepend, TextExtension)\n  Integer.send(:prepend, TextExtension)\n  Float.send(:prepend, TextExtension)\n  Operation.send(:prepend, RefExtension)\n#   include TissueCulture\n\n#######################################\n# OLA image processing API\n#######################################\n\n  # TODO add error handling to this function, since function could fail if api service disconnected\n  def make_calls_from_image(image_upload)\n    res = post_file(OLA_IP_API_URL, 'file', image_upload)\n    return JSON.parse(res.body)['results']\n  end\n\n#######################################\n# Utilities\n#######################################\n\n  def pluralizer(noun, num)\n    if num == 1\n      \"the #{noun.pluralize(num)}\"\n    elsif num == 2\n      \"both #{noun.pluralize(num)}\"\n    else\n      \"all #{num} #{noun.pluralize(num)}\"\n    end\n  end\n\n  def group_by_unit ops\n    ops.running.group_by {|op| op.temporary[:unit]}\n  end\n\n  def get_technician_name(job_id)\n    job = Job.find(job_id)\n    user_id = job.user_id\n    username = \"\\\"unknown user\\\"\"\n    unless user_id.nil?\n      username = User.find(job.user_id).name\n    end\n    username\n  end\n\n####################################\n# Item Alias\n####################################\n\n  def alias_helper(kit, unit, component, sample)\n    # returns the label given kit, unit, comp and sample\n    if !sample.blank?\n      \"#{unit}#{component}-#{sample}\"\n    else\n      \"#{unit}#{component}\"\n    end\n  end\n\n  def make_alias(item, kit, unit, component, patient, sample = nil)\n    sample = sample || \"\"\n    label = alias_helper(kit, unit, component, sample)\n    item.associate(ALIAS_KEY, label)\n    item.associate(KIT_KEY, kit)\n    item.associate(UNIT_KEY, unit)\n    item.associate(COMPONENT_KEY, component)\n    item.associate(SAMPLE_KEY, sample)\n    item.associate(PATIENT_KEY, patient)\n  end\n\n  def get_alias_array(item)\n    [item.get(KIT_KEY), item.get(UNIT_KEY), item.get(COMPONENT_KEY), item.get(SAMPLE_KEY), item.get(PATIENT_KEY)]\n  end\n\n  def ref(item)\n    \"#{item.get(UNIT_KEY)}#{item.get(COMPONENT_KEY)}-#{item.get(SAMPLE_KEY)}\"\n  end\n\n  def save_temporary_input_values(ops, input)\n    # get the aliases from the inputs\n    ops.each do |op|\n      kit, unit, component, sample, patient = get_alias_array(op.input(input).item)\n      op.temporary[:patient] = patient\n      op.temporary[:input_kit] = kit\n      op.temporary[:input_unit] = unit\n      op.temporary[:input_component] = component\n      op.temporary[:input_sample] = sample\n      op.temporary[:input_kit_and_unit] = [unit, kit].join('')\n    end\n  end\n  \n  def save_pack_hash(ops, pack)\n    ops.running.each do |op|\n      op.temporary[:pack_hash] = get_pack_hash(op.input(pack).sample)\n    end\n  end\n\n  def save_temporary_output_values(myops)\n    myops.each do |op|\n      op.temporary[:output_kit] = op.temporary[:input_kit]\n      op.temporary[:output_unit] = op.temporary[:pack_hash][UNIT_NAME_FIELD_VALUE]\n      op.temporary[:output_sample] = op.temporary[:input_sample]\n      op.temporary[:output_kit_and_unit] = [op.temporary[:output_unit], op.temporary[:output_kit]].join('')\n      op.temporary[:output_number_of_samples] = op.temporary[:pack_hash][NUM_SAMPLES_FIELD_VALUE]\n    end\n  end\n\n#   def save_temporary_output_values(myops, pack_field_value_name, unit)\n#     myops.each do |op|\n#       op.temporary[:output_kit] = op.temporary[:input_kit]\n#       op.temporary[:output_sample] = op.temporary[:input_sample]\n#       op.temporary[:output_unit] = unit\n#       op.temporary[:output_kit_and_unit] = [op.temporary[:output_kit], op.temporary[:output_unit]].join('')\n#     end\n#   end\n\n  def group_packages(myops)\n    myops.group_by {|op| op.temporary[:output_kit_and_unit]}\n  end\n\n\n####################################\n# Collection Alias\n####################################\n\n  def make_array_association(item, label, data)\n    raise \"must be an item not a collection for array associations\" unless item.is_a?(Item)\n    data.each.with_index do |d, i|\n      item.associate(\"#{label}#{i}\".to_sym, d)\n    end\n  end\n\n  def get_array_association(item, label, i)\n    item.get(\"#{label}#{i}\".to_sym)\n  end\n\n  def make_collection_alias(item, kit, unit, components, sample = nil)\n    sample = sample || \"\"\n    raise \"must be an item not a collection for array associations\" unless item.is_a?(Item)\n    item.associate(KIT_KEY, kit)\n    item.associate(UNIT_KEY, unit)\n    make_array_association(item, COMPONENT_KEY, components)\n    item.associate(SAMPLE_KEY, sample)\n  end\n\n  def collection_ref(collection, index)\n    component = get_array_association(collection, COMPONENT_KEY, index)\n    \"#{collection.get(KIT_KEY)}#{collection.get(UNIT_KEY)}#{component}#{collection.get(SAMPLE_KEY)}\"\n  end\n\n  def get_collection_refs(item, length)\n    length.times.map do |i|\n      collection_ref(item, i)\n    end\n  end\n\n####################################\n# Kit and Package Parser\n####################################\n\n  def parse_component(component_string)\n    # parses the component value for a OLASimple Package sample\n    # values are formatted as \"key: value\" or \"key: [val1, val2, val3]\"\n    val = nil\n    tokens = component_string.split(/\\s*\\:\\s*/)\n    m = /\\[(.+)\\]/.match(tokens[1])\n    if not m.nil?\n      arr_str = m[1]\n      val = arr_str.split(/\\s*,\\s*/).map {|x| x.strip()}\n    else\n      val = tokens[1]\n    end\n    return tokens[0], val\n  end\n\n  def get_component_dictionary(package_sample)\n    # parses all of the components in a OLASimple Package\n    components = package_sample.properties[COMPONENTS_FIELD_VALUE]\n    components.map {|v| [*parse_component(v)]}.to_h\n  end\n\n\n  def get_pack_hash(sample)\n    pack_hash = {}\n    # get the properties for the output pack sample\n    pack_hash = sample.properties\n\n    # parse the component values, formatted as \"key: value\" or \"key: [val1, val2, val3]\"\n    pack_hash[COMPONENTS_FIELD_VALUE] = get_component_dictionary(sample)\n    pack_hash\n  end\n\n  def get_kit_hash(op)\n    kit_hash = {}\n    # validates that input and output kits sample definitions are formatted correctly\n    [SAMPLE_PREP_FIELD_VALUE, PCR_FIELD_VALUE, LIGATION_FIELD_VALUE, DETECTION_FIELD_VALUE].each do |x|\n      # validate that the input kit is the same as the expected output kits\n      output_sample = op.output(x).sample\n      kit_hash[x] = get_pack_hash(output_sample)\n    end\n\n    kit_hash\n  end\n\n  def kit_hash_to_json(kit_hash)\n    h = kit_hash.map {|k, v| [k, v.reject {|key, val| key == KIT_FIELD_VALUE}]}.to_h\n    JSON.pretty_generate(h)\n  end\n\n  def validate_kit_hash(op, kit_hash)\n    # validates the kit hash\n    errors = []\n\n\n    kit_hash.each do |pack_name, pack_properties|\n      if pack_properties.empty?\n        errors.push([\"components_empty_for_#{pack_name}\".to_sym, \"Package components are empty!\"])\n      end\n\n      if pack_properties[KIT_FIELD_VALUE] != op.input(KIT_FIELD_VALUE).sample\n        errors.push([\"kit_not_found_in_input_for_#{pack_name}\".to_sym, \"Input kit does not match output package definition.\"])\n      end\n    end\n\n    kit_sample = op.input(KIT_FIELD_VALUE).sample\n    kit_sample_props = kit_sample.properties\n    num_codons = kit_sample_props[CODONS_FIELD_VALUE].length\n    num_codon_colors = kit_sample_props[CODON_COLORS_FIELD_VALUE].length\n    num_ligation_tubes = kit_hash[LIGATION_FIELD_VALUE][COMPONENTS_FIELD_VALUE][\"sample tubes\"].length\n    num_strips = kit_hash[DETECTION_FIELD_VALUE][COMPONENTS_FIELD_VALUE][\"strips\"].length\n\n    if debug\n      show do\n        title \"DEBUG: Kit Hash Errors\"\n        errors.each do |k, v|\n          note \"#{k}: #{v}\"\n        end\n      end\n    end\n\n    errors.each do |k, v|\n      op.error(k, v)\n    end\n\n    if debug\n      show do\n        title \"DEBUG: Kit Hash\"\n        note \"#{kit_hash_to_json(kit_hash)}\"\n        # note \"#{kit_hash}\"\n      end\n    end\n  end\n\n####################################\n# Step Utilities\n####################################\n\n  def check_for_tube_defects myops\n    # show do\n    defects = show do\n      title \"Check for cracked or damaged tubes.\"\n      select [\"No\", \"Yes\"], var: \"cracked\", label: \"If there are cracks or defects in the tube, select \\\"Yes\\\" from the dropdown menu below.\", default: 0\n      note \"If yes, #{SUPERVISOR} will replace the samples or tubes for you.\"\n    end\n\n    if defects[\"cracked\"] == \"Yes\"\n      show do\n        title \"Contact #{SUPERVISOR} about missing or damaged tubes.\"\n\n        note \"You said there are some problems with the samples.\"\n        check \"Contact #{SUPERVISOR} about this issue.\"\n        note \"We will simply replace these samples for you.\"\n      end\n    end\n  end\n\n  def area_preparation which_area, materials, other_area\n    show do\n     title \"Put on a pair of gloves\"\n    end\n\n    show do\n      title \"#{which_area.cap} preparation\"\n\n      note \"You will be doing the protocol in the #{which_area.bold} area\"\n      warning \"Put on a pair of gloves now\"\n      warning \"Keep all materials in the #{which_area.bold} area separate from the #{other_area.bold} area\"\n      note \"Before continuing, make sure you have the following items in the #{which_area.bold} area:\"\n      materials.each do |i|\n        check i\n      end\n    end\n  end\n\n  def put_on_ppe which_area\n    show do\n      title \"Put on Lab Coat and Gloves\"\n\n      check \"Put on a lab coat\"\n      warning \"make sure lab coat is from the #{which_area.bold}\"\n      check \"Put on a pair of latex gloves.\"\n    end\n  end\n\n  def transfer_title_proc(vol, from, to)\n    p = Proc.new {\n      title \"Add #{vol}uL from #{from.bold} to #{to.bold}\"\n    }\n    ShowBlock.new(self).run(\u0026p)\n  end\n\n  def show_open_package(kit, unit, num_sub_packages)\n    show do\n      title \"Tear open #{unit.bold}#{kit.bold}\"\n      if num_sub_packages \u003e 0\n        note \"Tear open all smaller packages.\"\n      end\n      self.run(\u0026Proc.new) if block_given?\n      check \"Discard the packaging material in the paper box on your right.\"\n    end\n  end\n\n  def centrifuge_proc(sample_identifier, sample_labels, time, reason, area, balance = false)\n    if area == PRE_PCR\n        centrifuge = CENTRIFUGE_PRE\n    elsif area == POST_PCR\n        centrifuge = CENTRIFUGE_POST\n    else\n        raise \"Invalid Area\"\n    end\n    p = Proc.new {\n      check \"Place #{sample_identifier.pluralize(sample_labels.length)} #{sample_labels.join(', ').bold} in the #{centrifuge}\"\n      check \"#{CENTRIFUGE_VERB.cap} #{pluralizer(sample_identifier, sample_labels.length)} for #{time} #{reason}\"\n      if balance\n        if num.even?\n          warning \"Balance tubes in the #{centrifuge} by placing #{num / 2} #{sample_identifier.pluralize(num / 2)} on each side.\"\n        else\n          warning \"Use a spare tube to balance #{sample_identifier.pluralize(num)}.\"\n        end\n      end\n    }\n    ShowBlock.new(self).run(\u0026p)\n  end\n\n  def vortex_proc(sample_identifier, sample_labels, time, reason)\n    p = Proc.new {\n      # check \"Vortex #{pluralizer(sample_identifier, num)} for #{time} #{reason}\"\n      check \"Vortex #{sample_identifier.pluralize(sample_labels.length)} #{sample_labels.join(', ').bold} for #{time} #{reason}\"\n      # check \"Vortex #{sample_identifier.pluralize(sample_labels.length)} #{sample_labels.map { |label| label.bold })}\n    }\n    ShowBlock.new(self).run(\u0026p)\n  end\n\n  def centrifuge_helper(sample_identifier, sample_labels, time, reason, area, mynote = nil)\n    sample_labels = sample_labels.uniq\n    show do\n      title \"#{CENTRIFUGE_VERB.cap} #{sample_identifier.pluralize(sample_labels.length)} for #{time}\"\n      if not mynote.nil?\n        note mynote\n      end\n      warning \"Ensure #{pluralizer(\"tube cap\", sample_labels.length)} are closed before centrifuging.\"\n      raw centrifuge_proc(sample_identifier, sample_labels, time, reason, area)\n    end\n  end\n\n  def vortex_helper(sample_identifier,\n                    sample_labels,\n                    vortex_time,\n                    vortex_reason, mynote = nil)\n    num = sample_labels.length\n    show do\n      title \"Vortex #{sample_identifier.pluralize(num)}\"\n      if not mynote.nil?\n        note mynote\n      end\n      warning \"Close #{pluralizer(\"tube cap\", sample_labels.length)}.\"\n      raw vortex_proc(sample_identifier, sample_labels, vortex_time, vortex_reason)\n    end\n  end\n\n  def vortex_and_centrifuge_helper(sample_identifier,\n                                   sample_labels,\n                                   vortex_time, spin_time,\n                                   vortex_reason, spin_reason, area, mynote = nil)\n    num = sample_labels.length\n    show do\n      title \"Vortex and #{CENTRIFUGE_VERB} #{sample_identifier.pluralize(num)}\"\n      if not mynote.nil?\n        note mynote\n      end\n      warning \"Close #{pluralizer(\"tube cap\", sample_labels.length)}.\"\n      # note \"Using #{sample_identifier.pluralize(num)} #{sample_labels.join(', ').bold}:\"\n      raw vortex_proc(sample_identifier, sample_labels, vortex_time, vortex_reason)\n      raw centrifuge_proc(sample_identifier, sample_labels, spin_time, spin_reason, area)\n      check \"Place the tubes back on rack\"\n    end\n  end\n\n  def add_to_thermocycler(sample_identifier, sample_labels, program_name, program_table, name)\n    if sample_labels.is_a?(Array)\n      len = sample_labels.length\n    else\n      len = sample_labels\n    end\n\n    show do\n      title \"Run #{name}\"\n      check \"Add #{pluralizer(sample_identifier, len)} to #{THERMOCYCLER}\"\n      check \"Close and tighten the lid.\"\n      check \"Select the program named #{program_name.bold} under the \u003cb\u003eOS\u003c/b\u003e\"\n      check \"Hit \u003cb\u003e\\\"Run\\\"\u003c/b\u003e and click \u003cb\u003e\\\"OK\\\"\u003c/b\u003e\"\n      table program_table\n    end\n  end\n\n  def clean_area which_area\n    show do\n      disinfectant = \"10% bleach\"\n      title \"Wipe down #{which_area.bold} with #{disinfectant.bold}.\"\n      note \"Now you will wipe down your #{BENCH} and equipment with #{disinfectant.bold}.\"\n      check \"Spray #{disinfectant.bold} onto a #{WIPE} and clean off pipettes and pipette tip boxes.\"\n      check \"Spray a small amount of #{disinfectant.bold} on the bench surface. Clean bench with #{WIPE}.\"\n      # check \"Spray some #{disinfectant.bold} on a #{WIPE}, gently wipe down keyboard and mouse of this computer/tablet.\"\n      warning \"Do not spray #{disinfectant.bold} onto tablet or computer!\"\n      check \"Finally, spray outside of gloves with #{disinfectant.bold}.\"\n    end\n\n    show do\n      disinfectant = \"70% ethanol\"\n      title \"Wipe down #{which_area.bold} with #{disinfectant.bold}.\"\n      note \"Now you will wipe down your #{BENCH} and equipment with #{disinfectant.bold}.\"\n      check \"Spray #{disinfectant.bold} onto a #{WIPE} and clean off pipettes and pipette tip boxes.\"\n      check \"Spray a small amount of #{disinfectant.bold} on the bench surface. Clean bench with #{WIPE}.\"\n      #   check \"Spray a #{\"small\".bold} amount of #{disinfectant.bold} on a #{WIPE}. Gently wipe down keyboard and mouse of this computer/tablet.\"\n      warning \"Do not spray #{disinfectant.bold} onto tablet or computer!\"\n      check \"Finally, spray outside of gloves with #{disinfectant.bold}.\"\n    end\n  end\n\n  def area_setup area, materials, other_area = nil\n    area_preparation area, materials, other_area\n    put_on_ppe area\n    clean_area area\n  end\n\n\n####################################\n# Displaying Images\n######################################\n  def extract_basename filename\n    ext = File.extname(filename)\n    basename = File.basename(filename, ext)\n    basename\n  end\n\n  def show_with_expected_uploads(op, filename, save_key = nil, num_tries = 5)\n    upload_hashes = []\n    warning_msg = nil\n    num_tries.times.each do |i|\n      if upload_hashes.empty?\n        # ask for uploads\n        result = show do\n          warning warning_msg unless warning_msg.nil?\n          self.run(\u0026Proc.new) if block_given?\n          upload var: :files\n        end\n        upload_hashes = result[:files] || []\n\n        if debug and i \u003e= 1\n          n = \"default_filename.txt\"\n          if i \u003e= 2\n            n = filename\n          end\n          upload_hashes.push({:id =\u003e 12345, :name =\u003e n})\n        end\n\n        # try again if not files were uploaded\n        if upload_hashes.empty?\n          warning_msg = \"You did not upload any files! Please try again.\"\n        end\n\n        unless upload_hashes.empty?\n          # get name to id hash\n          name_to_id_hash = upload_hashes.map {|u| [extract_basename(u[:name]), u[:id]]}.to_h\n\n          # get the file even if technician uploaded multiple files\n          if name_to_id_hash.keys.include?(extract_basename(filename))\n            upload_hashes = [{name: filename, id: name_to_id_hash[filename]}]\n          else\n            warning_msg = \"File #{filename} not uploaded. Please find file \u003cb\u003e\\\"#{filename}\\\"\u003c/b\u003e. You uploaded files #{name_to_id_hash.keys.join(', ')}\"\n            upload_hashes = []\n          end\n        end\n      end\n    end\n    raise \"Expected file uploads, but there were none!\" if upload_hashes.empty?\n\n    upload_ids = upload_hashes.map {|uhash| uhash[:id]}\n    uploads = []\n    if debug\n      random_uploads = Upload.includes(:job)\n      uploads = upload_ids.map {|u| random_uploads.sample}\n    else\n      uploads = upload_ids.map {|u_id| Upload.find(u_id)}\n    end\n    upload = uploads.first\n    op.temporary[save_key] = upload unless save_key.nil?\n    op.temporary[\"#{save_key}_id\".to_sym] = upload.id unless save_key.nil?\n    return upload\n  end\n\n  def display_upload(upload, size = \"100%\")\n    p = Proc.new do\n      note \"\u003cimg src=\\\"#{upload.expiring_url}\\\" width=\\\"#{size}\\\"\u003e\u003c/img\u003e\"\n    end\n    ShowBlock.new(self).run(\u0026p)\n  end\n\n    def display_strip_section(upload, display_section, num_sections, size)\n      p = Proc.new do\n          x = 100.0/num_sections\n          styles = []\n          num_sections.times.each do |section|\n              x1 = 100 - (x * (section+1)).to_i\n              x2 = (x*(section)).to_i\n              styles.push(\".clipimg#{section} { clip-path: inset(0% #{x1}% 0% #{x2}%); }\")\n          end\n          style = \"\u003chead\u003e\u003cstyle\u003e#{styles.join(' ')}\u003c/style\u003e\u003c/head\u003e\"\n          note style\n          note \"\u003cimg class=\\\"clipimg#{display_section}\\\" src=\\\"#{upload.expiring_url}\\\" width=\\\"#{size}\\\"\u003e\u003c/img\u003e\" \n      end\n      ShowBlock.new(self).run(\u0026p)\n  end\n\nend"}},{"library":{"name":"OLAScheduling","category":"OLASimple","code_source":"module OLAScheduling\n  \n  SCHEDULER_USER = User.first\n  \n  # redundant definitions from OLAConstants required to get around precondition limitations\n  BATCH_SIZE = 2\n  KIT_KEY = :kit\n  KIT_PARAMETER = \"Kit Identifier\"\n  \n  # retrieve kit id from first input's associations if avialable,\n  # also try to retrieve kit id from a kit input parameter if it is available.\n  # returns nil if no kit could be found\n  def get_kit_id(op)\n    op.inputs[0].retrieve\n    op.inputs[0].item\u0026.get(KIT_KEY) || op.input(KIT_PARAMETER)\u0026.value\n  end\n  \n  # return if this protocol is being run in developer testing mode \n  def testing_mode?(op)\n    op.plan.nil?\n  end\n  \n  # used in place of returning true in precondition\n  # gathers together all the other ops with the same kit\n  # and schedules them together if they are all ready\n  # looks at this_op.inputs[0].item.get(KIT_KEY) to decide what kit an op belongs\n  # \n  def schedule_same_kit_ops(this_op)\n    return true if testing_mode?(this_op)\n\n    kit_id = get_kit_id(this_op)\n    if kit_id.nil?\n      this_op.error(:no_kit, \"This operation did not have an associated kit id in its input and so couldn't be batched\")\n      exit\n    end\n    \n    operations = Operation.where({operation_type_id: this_op.operation_type_id, status: [\"pending\"]})\n    this_op.status = \"pending\"\n    this_op.save\n    operations \u003c\u003c this_op\n    operations = operations.to_a.uniq\n    operations = operations.select { |op| get_kit_id(op) == kit_id }\n    if operations.length == BATCH_SIZE\n      Job.schedule(\n        operations: operations,\n        user: SCHEDULER_USER\n      )\n    elsif operations.length \u003e BATCH_SIZE\n      operations.each do |op|\n        op.error(:batch_too_big, \"There are too many samples being run with kit #{kit_id}. The Batch size is set to #{BATCH_SIZE}, but there are #{operations.length} operations which list #{kit_id} as their kit association.\")\n        op.save\n        op.plan.error(\"There are too many samples being run with kit #{kit_id}. The Batch size is set to #{BATCH_SIZE}, but there are #{operations.length} operations which list #{kit_id} as their kit association.\", :batch_too_big)\n        op.plan.save\n      end\n    end\n    exit\n  end\nend"}},{"library":{"name":"SVGGraphics","category":"OLASimple","code_source":"############################################\n#\n# Generic SVG Graphics for lab work\n#\n############################################\n\nrequire 'matrix'\n\nmodule Graphics\n\n  class Tag\n    # an HTML/XML like tag\n    #\n    def initialize(tag_name, value: nil, properties: nil)\n      if properties.nil?\n        properties = {}\n      end\n      if value.nil?\n        value = \"\"\n      end\n      @tag_name = tag_name\n      @properties = properties\n      @value = value\n    end\n\n    def Tag.property(label, value)\n      return \"#{label}=\\\"#{value}\\\"\"\n    end\n\n    def value\n      @value\n    end\n\n    def update(props)\n      @properties = @properties.merge(props)\n    end\n\n    def properties\n      @properties.select {|_, v|\n        !v.nil? and v != \"\"}.map {|k, v|\n        Tag.property(k, v)\n      }.join(' ')\n    end\n\n    def formatter\n      REXML::Formatters::Pretty.new\n    end\n\n    def to_str\n      props = self.properties\n      if props != \"\"\n        props = \" \" + props\n      end\n      if self.value == \"\"\n        return \"\u003c#{@tag_name}#{props} /\u003e\"\n      end\n\n      mystr = \"\u003c#{@tag_name}#{props}\u003e#{self.value}\u003c/#{@tag_name}\u003e\"\n      return mystr\n      mydoc = REXML::Document.new(mystr)\n      self.formatter.write(mydoc.root, \"\")\n    end\n\n    def dump\n      {\n          properties: @properties,\n          value: @value,\n          tag_name: @tag_name\n      }\n    end\n\n    def self.load(props)\n      print(\"loading #{self}\")\n      return self.new(props[:tag_name], value: props[:value], properties: props[:properties])\n    end\n\n    def inst\n      self.class.load(self.dump)\n    end\n\n    # def inst\n    #   Marshal.load(Marshal.dump(self))\n    # end\n\n    def to_s\n      self.to_str\n    end\n  end\n\n  # A vector image, like an icon\n  class SVGElement \u003c Tag\n    attr_accessor :alignment, :value, :boundx, :boundy\n    attr_reader :x, :y, :yscale, :rot, :xposrot, :yposrot, :xscale, :yscale, :name, :classname, :transformations\n\n    @@debug = false\n\n    # A SVG element to display in an image\n    #\n    def initialize(children: nil,\n                   name: nil,\n                   classname: nil,\n                   x: 0,\n                   y: 0,\n                   boundx: 0,\n                   boundy: 0,\n                   alignment: 'top-left',\n                   xscale: 1,\n                   yscale: 1,\n                   rot: 0,\n                   xposrot: 0,\n                   yposrot: 0,\n                   properties: nil,\n                   transformations: nil,\n                   style: nil)\n      properties = properties || {}\n      classname = classname || \"\"\n      children = [children] unless children.is_a?(Array)\n      super(\"g\", properties: properties)\n      @name = name\n      @classname = classname\n      @boundx = boundx\n      @boundy = boundy\n      @children = children\n      @alignment = alignment\n      @style = style || \"\"\n      @transformations = transformations || []\n      self.update_coordinates!(x, y)\n      @xscale = xscale\n      @yscale = yscale\n      if @transformations.empty?\n        self.transform!(x: x, y: y, xscale: xscale, yscale: yscale, rot: rot, xposrot: xposrot, yposrot: yposrot)\n      end\n    end\n\n    def update_coordinates!(x, y)\n      @x = x\n      @y = y\n    end\n\n    def dump\n      tag_props = super\n      tag_props.reject! {|k, v| [\"tag_name\", \"value\"].include?(k.to_s)}\n      props = {\n          x: @x,\n          y: @y,\n          xscale: @xscale,\n          yscale: @yscale,\n          name: @name,\n          classname: @classname,\n          alignment: @alignment,\n          style: @style,\n          transformations: @transformations.dup.compact,\n          children: @children.dup.compact,\n          boundx: @boundx,\n          boundy: @boundy\n      }\n      props.merge(tag_props)\n    end\n\n    def self.load(props)\n      self.new(**props)\n    end\n\n    # sets the debug mode on or off\n    # debug mode will display bounding boxes and anchors\n    def self.debug onoroff\n      @@debug = onoroff\n    end\n\n    def value\n      # override the Tag value for converting SVGElement to a string\n      @value = \"\\n#{self.display}\"\n      super\n    end\n\n    def new_class(myclass)\n      inst = self.inst\n      inst.new_class!(myclass)\n    end\n\n    def new_name(myname)\n      inst = self.inst\n      inst.new_name!(myname)\n    end\n\n    def new_class!(myclass)\n      @classname = myclass\n      self\n    end\n\n    def new_name!(myname)\n      @name = myname\n      self\n    end\n\n    def svg_properties\n      # additional svg properties\n      props = {}\n      if @name != \"\"\n        props[\"id\"] = @name\n      end\n      if @classname != \"\"\n        props[\"class\"] = @classname\n      end\n      props[\"transform\"] = self.get_transform_attribute\n      props\n    end\n\n    def properties\n      # override the Tab properties to add additional svg-specific properties\n      # such as id=\"\" and transform\n      @properties = @properties.merge(self.svg_properties)\n      super\n    end\n\n    def origin\n      self.get_anchor(\"upper-left\")\n    end\n\n    def bounds\n      self.bounds_helper(0, 0)\n      # use min?\n    end\n\n    def align_with(other, other_anchor)\n      self.translate!(-@x, -@y)\n      v = other.get_abs_anchor(other_anchor)\n      v = v - other.abs_anchor_vector\n      # v = other.get_abs_anchor_vector(other_anchor)\n      #\n      self.translate!(*v)\n    end\n\n    def g id: nil, classname: nil\n      # return a external new group with svg element as a child\n      new_g = SVGElement.new(name: id, properties: {\"class\" =\u003e classname}, x: 0, y: 0)\n      new_g.update_coordinates!(@x, @y)\n      new_g.boundx = @boundx * @xscale\n      new_g.boundy = @boundy * @yscale\n      new_g.add_child(self)\n    end\n\n    # Sets the children array\n    def children=(g)\n      @children = g\n    end\n\n    # Returns the children array\n    def children\n      @children\n    end\n\n    def display\n      inst = self\n      if @@debug\n        inst = inst.display_with_anchors.bb\n      end\n      if inst.children.is_a?(Array)\n        inst.children.map do |child|\n          if child.is_a?(SVGElement)\n            \"#{child}\"\n          else\n            child\n          end\n        end.join(\"\\n\")\n      else\n        \"#{inst.children}\"\n      end\n    end\n\n    def add_child(child)\n      if child.is_a?(String)\n        @children.push(child)\n      else\n        @children.push(child.inst)\n      end\n      self\n    end\n\n    def group_children id: nil, classname: nil\n      # make an internal grouping of this elements children. Return that grouping\n      child_group = SVGElement.new(name: id, classname: classname)\n      child_group.children = self.children\n      self.children = [child_group]\n      return child_group\n    end\n\n    def cx\n      return (@x + @boundx) / 2.0\n    end\n\n    def cy\n      return (@y + @boundy) / 2.0\n    end\n\n    # ########################################################\n    # Transformation\n    # ########################################################\n\n    # scaling always happens last in SVG transform attribute to avoid unusual SVG behavior\n    def get_transform_attribute\n      # transformations = [self.apply_scale, self.apply_translate, self.apply_rotate]\n      transformations = []\n      transformations += @transformations.dup\n      transformations.push(\"scale(#{@xscale} #{@yscale})\")\n      transformations.push(self.anchor_translate)\n      attr = transformations.join(' ')\n      zero = \"(-){0,1}0(\\.0){0,1}\"\n      attr.gsub!(/translate\\((-){0,1}0(\\.0){0,1} (-){0,1}0(\\.0){0,1}\\)/, '')\n      attr.gsub!(/translate\\((-){0,1}0(\\.0){0,1}\\)/, '')\n      attr.gsub!(/rotate\\((-){0,1}0(\\.0){0,1} (-){0,1}0(\\.0){0,1} (-){0,1}0(\\.0){0,1}\\)\\s+/, \"\")\n      attr.gsub!(/scale\\(1\\)\\s+/, \"\")\n      attr.gsub!(/scale\\(1 1\\)\\s+/, \"\")\n      attr.strip.gsub(/\\s+/, \" \")\n    end\n\n    def align!(alignment)\n      self.alignment = alignment\n      self\n    end\n\n    def mirror_horizontal\n      child_group = self.group_children(id: \"mirror_horizontal\")\n      child_group.scale!(-1, 1).translate!(@boundx, 0)\n      return self\n    end\n\n    def mirror_vertical\n      child_group = self.group_children(id: \"mirror_vertical\")\n      child_group.scale!(1, -1).translate!(0, @boundy)\n      return self\n    end\n\n    def translate!(x, y = 0)\n      @x += x\n      y = y || 0\n      @y += y\n      if x != 0 or y != 0\n        @transformations.push self.translate_helper(x, y)\n      end\n      self\n    end\n\n    def rotate!(a, x = 0, y = 0)\n      if a != 0\n        @transformations.push self.rotate_helper(a, x, y)\n      end\n      self\n    end\n\n    # Scalings must always happen last to avoid unusual SVG behaviors\n    def scale!(x, y = nil)\n      if y.nil?\n        y = x\n      end\n      @xscale = x\n      @yscale = y\n      # if x != 1 and y != 1\n      #   @transformations.push self.scale_helper(x, y)\n      # end\n      self\n    end\n\n    def transform!(x: 0, y: 0, xscale: 1, yscale: 1, rot: 0, xposrot: 0, yposrot: 0)\n      # update the tranform values\n      self.translate!(x, y)\n          .rotate!(rot, xposrot, yposrot)\n          .scale!(xscale, yscale)\n    end\n\n    def translate(x, y = nil)\n      i = self.inst\n      i.translate!(x, y)\n    end\n\n    def rotate(a, x = 0, y = 0)\n      i = self.inst\n      i.rotate!(a, x, y)\n    end\n\n    def scale(x, y = nil)\n      i = self.inst\n      i.scale!(x, y)\n    end\n\n    def align(alignment)\n      inst = self.inst\n      inst.align!(alignment)\n    end\n\n    def transform(x: 0, y: 0, xscale: 1, yscale: 1, rot: 0, xposrot: 0, yposrot: 0)\n      # update the tranform values\n      inst = self.inst\n      inst.transform!(x: x, y: y, xscale: xscale, yscale: yscale, rot: rot, xposrot: xposrot, yposrot: yposrot)\n    end\n\n    def translate_helper(x, y = 0)\n      \"translate(#{x} #{y})\"\n    end\n\n    def rotate_helper(a, x = 0, y = 0)\n      # a: degrees\n      # x: rotate point\n      # y: rotate point\n      \"rotate(#{a} #{x} #{y})\"\n    end\n\n\n    def scale_helper(x, y = 1)\n      # a: degrees\n      # x: rotate point\n      # y: rotate point\n      \"scale(#{x} #{y})\"\n    end\n\n    def anchor_translate\n      x = self.anchor_vector\n      self.translate_helper(-x[-0], -x[1])\n    end\n\n    def apply_rotate\n      self.rotate_helper(@rot, @xposrot, @yposrot)\n    end\n\n    def apply_scale\n      self.scale_helper(@xscale, @yscale)\n    end\n\n    # ########################################################\n    # Anchors\n    # ########################################################\n\n    def get_anchor_vector(alignment)\n      anchor_matrix = self.parse_alignment alignment\n      cw = @boundx / 2.0\n      cy = @boundy / 2.0\n      Vector[(anchor_matrix[0] + 1) * cw, (anchor_matrix[1] + 1) * cy]\n    end\n\n    def anchor_vector\n      self.get_anchor_vector @alignment\n    end\n\n    def get_anchor alignment\n      p = Vector[@x, @y]\n      p + self.get_anchor_vector(alignment)\n    end\n\n    def anchor\n      p = Vector[@x, @y]\n      p + self.get_anchor_vector(@alignment)\n    end\n\n    def get_abs_anchor alignment\n      p = Vector[@x, @y]\n      p + self.get_abs_anchor_vector(alignment)\n    end\n\n    def abs_anchor\n      self.get_abs_anchor(@alignment)\n    end\n\n    # multiple the anchor vector by the scaling vector\n    def abs_anchor_vector\n      return self.get_abs_anchor_vector(@alignment)\n    end\n\n    def get_abs_anchor_vector alignment\n      a = self.get_anchor_vector(alignment)\n      return Vector[@xscale * a[0], @yscale * a[1]]\n    end\n\n    def display_with_anchors\n      if @name == 'debuganchor'\n        return self\n      end\n      cross = SVGElement.new(name: \"debuganchor\", boundx: 10, boundy: 10)\n      cross.add_child Tag.new('line', properties: {x1: 0, y1: 0, x2: 10, y2: 10, stroke: 'red', 'stroke-width' =\u003e 0.5})\n      cross.add_child Tag.new('line', properties: {x2: 0, y1: 0, x1: 10, y2: 10, stroke: 'red', 'stroke-width' =\u003e 0.5})\n      cross.add_child Tag.new('rect', properties: {x: 0, y: 0, width: 10, height: 10, stroke: 'red', fill: 'none', 'stroke-width' =\u003e 0.5})\n      cross.scale!(0.75)\n      cross.align!('center-center')\n      inst = self.inst\n      halign = ['left', 'center', 'right']\n      valign = ['top', 'center', 'bottom']\n      halign.each do |h|\n        valign.each do |v|\n          inst.add_child(cross.translate(*inst.get_anchor_vector(\"#{h}-#{v}\")))\n        end\n      end\n      inst\n    end\n\n    def bb\n      if @name == \"debuganchor\"\n        return self\n      end\n      inst = self.inst\n      ax, ay = self.anchor\n      bounding_box = Tag.new('rect', properties: {\n          x: 0,\n          y: 0,\n          width: @boundx,\n          height: @boundy,\n          \"stroke-width\" =\u003e 0.5,\n          stroke: 'red',\n          fill: 'none'\n      })\n      inst.add_child(bounding_box)\n    end\n\n    def parse_alignment(alignment)\n      # parses an alignment string like 'center-left'\n\n      tokens = alignment.split('-')\n      if tokens.length != 2\n        raise \"Property 'alignment=#{alignment}' is improperly formatted (e.g. use 'alignment=\\\"center-left\\\"')\"\n      end\n\n      if ['left', 'right'].include?(tokens[1])\n        tokens[0], tokens[1] = tokens[1], tokens[0]\n      end\n\n      if ['upper', 'bottom', 'top'].include?(tokens[0])\n        tokens[0], tokens[1] = tokens[1], tokens[0]\n      end\n\n      if ['left', 'right'].include?(tokens[1])\n        raise \"Property 'alignment' not understood. Cannot be aligned to both left and right. Found '#{alignment}'\"\n      end\n\n      if ['top', 'upper', 'bottom'].include?(tokens[0])\n        raise \"Property 'alignment' not understood. Cannot be aligned to both top and bottom. Found '#{alignment}'\"\n      end\n\n      anchor_dict = {\n          left: -1,\n          center: 0,\n          right: 1,\n          upper: -1,\n          top: -1,\n          bottom: 1\n      }\n      tokens.map {|t| anchor_dict[t.to_sym]}\n    end\n\n    # change relative coordinates to absolute coordinates\n    def v(x, y)\n      return Vector[x, y]\n    end\n\n    def abs_v(x, y)\n      return Vector[@xscale * x, @yscale * y]\n    end\n\n    def style(mystyle)\n      inst = self.inst\n      inst.style!(mystyle)\n    end\n\n    def style!(mystyle)\n      @style = Tag.new(\"style\", value: mystyle)\n    end\n\n    def svg(width=nil, height=nil, scale = 1.0)\n      width = width || @boundx * @xscale\n      height = height || @boundy * @yscale\n      Tag.new('svg',\n              value: [@style, self.g(id: \"svg\").to_str].join(''), properties: {\n              width: \"#{width * scale}px\",\n              height: \"#{height * scale}px\",\n              viewBox: \"0 0 #{width} #{height}\",\n              version: \"1.1\",\n              xmlns: \"http://www.w3.org/2000/svg\"\n          })\n    end\n  end\n\n  class Shape \u003c SVGElement\n    def initialize(x, y, shape, stroke = 'black', stroke_width = 1, shapevalue = nil, *args)\n\n      super(*args)\n      if @shape_properties.nil?\n        @shape_properties = {}\n      end\n      @shape = shape\n      @shapevalue = shapevalue\n      self.update({stroke: stroke, \"stroke-width\" =\u003e stroke_width})\n    end\n\n    def dump\n      elements_props = super\n      {\n          shape_properties: @shape_properties,\n          shape: @shape,\n          shapevalue: @shapevalue,\n          element_props: elements_props\n      }\n    end\n\n    def self.load(props)\n      new = self.new(0, 0, props[:shape], 'black', 1, props[:shapevalue], **props[:element_props])\n      new.update(props[:shape_properties])\n    end\n\n    def inst\n      self.class.load(self.dump)\n    end\n\n    # def inst\n    #   Marshal.load(Marshal.dump(self))\n    # end\n\n    def get_child\n      Tag.new(@shape, value: @shapevalue, properties: @shape_properties)\n    end\n\n    def update new_hash\n      @shape_properties.merge!(new_hash)\n      @children[0] = self.get_child\n      self\n    end\n  end\n\n  class Rect \u003c Shape\n    def initialize(x, y, width, height, *args)\n      @shape_properties = {width: width, height: height}\n      super(x, y, 'rect', *args)\n      @boundx = width\n      @boundy = height\n    end\n  end\n\n  class Circle \u003c Shape\n    def initialize(x, y, r, *args)\n      @shape_properties = {r: r, cx: 0, cy: 0}\n      super(x, y, 'circle', *args)\n    end\n  end\n\n  class Line \u003c Shape\n    def initialize(x1, y1, x2, y2, *args)\n      @shape_properties = {\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2}\n      super(0, 0, 'line', *args)\n    end\n  end\n\n  class VectorLine \u003c Shape\n    def initialize(x, y, dx, dy, *args)\n      @shape_properties = {x1: 0, y1: 0, x2: dx, y2: dy}\n      super(x, y, 'line', *args)\n    end\n  end\n\n  def label(text, properties = nil)\n    properties = properties || {}\n    font_size = properties[:font_size] || 12\n    boundx = font_size * text.length * 0.5\n    boundy = font_size\n    mylabel = SVGElement.new(boundx: boundx, boundy: boundy)\n    a = mylabel.get_anchor_vector('center-center')\n    properties[:x] = a[0]\n    properties[:y] = a[1]\n    properties[\"alignment-baseline\".to_sym] = 'middle'\n    properties[\"text-anchor\".to_sym] = 'middle'\n    properties['font-family'.to_sym] = \"Verdana\"\n    mylabel.add_child(\n        Tag.new(\"text\", value: text, properties: properties)\n    )\n  end\n\n  # class Label \u003c Shape\n  #   def initialize(label, font_size, x = 0, y = 0, font_family = \"Arial\", stroke='black', stroke_width=0, *args)\n  #     @shape_properties = {\n  #         x: 0, y: 0,\n  #         \"font-size\" =\u003e font_size,\n  #         \"font-family\" =\u003e font_family,\n  #         'alignment-baseline' =\u003e 'middle',\n  #         'text-anchor' =\u003e 'middle'}\n  #     label = label || \"\"\n  #     super(x, y, 'text', stroke, stroke_width, @shapevalue, *args)\n  #     @shapevalue = label\n  #     @boundy = font_size\n  #     @boundx = @shapevalue.length * font_size\n  #     self.update({})\n  #   end\n  #\n  #   def self.load(props)\n  #     new = self.new(props[:shapevalue], 0, 0, 0, \"Arial\", \"black\", 0, props[:element_props])\n  #     new.update(props[:shape_properties])\n  #   end\n  #\n  #   # Override x, y position so that label aligns with anchor\n  #   def get_child\n  #     s = @shape_properties.dup\n  #     av = self.get_anchor_vector('center-center')\n  #     s[:x] = av[0]\n  #     s[:y] = av[1]\n  #     Tag.new(@shape, value: @shapevalue, properties: s)\n  #   end\n  #\n  #   # auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | inherit\n  #   def vertical_alignment(alignment)\n  #     self.update('alignment-baseline' =\u003e alignment)\n  #   end\n  #\n  #   # start | middle | end | inherit\n  #   def text_anchor(alignment)\n  #     self.update('text-anchor' =\u003e alignment)\n  #   end\n  # end\n\n  # Organizes SVGElements on a grid of your choosing.\n  # Makes it easier to position elements\n  class SVGGrid \u003c SVGElement\n    attr_accessor :elements\n\n    def initialize(xnum, ynum, xspacing, yspacing, *args)\n      super(*args)\n      if @name == \"\"\n        @name = \"grid\"\n      end\n      @xnum = xnum\n      @ynum = ynum\n      @xspacing = xspacing\n      @yspacing = yspacing\n      @boundx = self.boundx\n      @boundy = self.boundy\n      @elements = Array.new(xnum) {Array.new(ynum) {[]}} # 3d array for displaying some elements on a 2D grid\n    end\n\n    def dump\n      element_props = super\n      {\n          xspacing: @xspacing,\n          yspacing: @yspacing,\n          xnum: @xnum,\n          ynum: @ynum,\n          element_props: element_props,\n          elements: @elements\n      }\n    end\n\n    def self.load(props)\n      newgrid = SVGGrid.new(props[:xnum], props[:ynum], props[:xspacing], props[:yspacing], props[:element_props])\n      newgrid.update_elements(props[:elements])\n      newgrid\n    end\n\n    def update_elements elements\n      if elements.length != @xnum\n        raise \"Cannot update_elements. Number of rows must equal #{xnum} but was #{elements.length}\"\n      end\n\n      col_lengths = elements.map {|row| row.length}.uniq\n\n      if col_lengths.length != 1\n        raise \"Cannot update_elements. Rows have different number of columns.\"\n      end\n\n      if elements[0].length != @ynum\n        raise \"Cannot update_elements. Number of columns must equal #{@ynum} but was #{elements[0].length}\"\n      end\n\n      @elements = elements\n    end\n\n    def inst\n      self.class.load(self.dump)\n    end\n\n    # def inst\n    #   Marshal.load(Marshal.dump(self))\n    # end\n\n\n    def pos(r, c)\n      return Vector[r * @xspacing, c * @yspacing]\n    end\n\n    def abs_pos_vector(r, c)\n      v = self.pos(r, c)\n      return Vector[@xscale * v[0], @yscale * v[1]]\n    end\n\n    def grid_coor(r, c, x, y)\n      px, py = self.pos(r, c)\n      return [px + x, py + y]\n    end\n\n    def grid_elements\n      @elements.map.with_index do |row, r|\n        x = self.pos(r, 0)[0]\n        row_element = SVGElement.new(name: \"gridrow#{r}\").translate(x, 0)\n        row.each.with_index do |element, c|\n          y = pos(0, c)[1]\n          col_element = SVGElement.new(name: \"gridcol#{c}\").translate(0, y)\n          col_element.children = element\n\n          # don't add empty columns\n          if not element.nil? and not element == \"\" and not element == []\n            row_element.add_child(col_element)\n          end\n        end\n\n        # don't add empty rows\n        row_element unless row_element.children.empty?\n      end.compact\n    end\n\n    def children\n      children = @children.dup\n      grid_elements = self.grid_elements\n      grid_elements + children\n    end\n\n    def group_children id: nil, classname: nil\n      raise \"Cannot group children of a SVGGrid. Group using '.g' before grouping children\"\n    end\n\n    def add(element, x, y)\n      xfloor = x.floor\n      xrem = (x - xfloor).round(1)\n      yfloor = y.floor\n      yrem = (y - yfloor).round(1)\n\n      if xrem \u003e 0 or yrem \u003e 0\n        element = element.g(id: \"gridshift\").translate(xrem * @xspacing, yrem * @yspacing)\n      end\n      ele = @elements[xfloor][yfloor]\n      if ele.nil?\n        ele = []\n      end\n      ele.push(element)\n      @elements[xfloor][yfloor] = ele\n    end\n\n    # TODO: maximum width from individual elements bounding boxes...\n    def boundx\n      @xnum * @xspacing\n    end\n\n    # TODO: maximum height from individual elements bounding boxes...\n    def boundy\n      @ynum * @yspacing\n    end\n\n    # Applies the block through each element in the grid\n    def each\n      raise \"#{self.class.name}.each needs a selection block\" unless block_given?\n      @elements.each.with_index do |row, r|\n        row.each.with_index do |col, c|\n          col.each do |element|\n            Proc.new.call(element)\n          end\n        end\n      end\n    end\n\n    # Applies the block through each row, col in the grid\n    def each_pos\n      raise \"#{self.class.name}.each_pos needs a selection block\" unless block_given?\n      @elements.each.with_index do |row, r|\n        row.each.with_index do |col, c|\n          Proc.new.call(r, c)\n        end\n      end\n    end\n\n    def elements_at(r, c)\n      @elements[r][c]\n    end\n\n    def select\n      raise \"#{self.class.name}.select needs a selection block\" unless block_given?\n      selected = []\n      @elements.each.with_index do |row, r|\n        row.each.with_index do |col, c|\n          if Proc.new.call(r, c)\n            selected.push(col)\n          end\n        end\n      end\n      return selected\n    end\n\n    # def add_each_pos\n    #   raise \"#{self.class.name}.add_each_pos needs a selection block\" unless block_given?\n    #   @elements.each.with_index do |row, r|\n    #     row.each.with_index do |col, c|\n    #       new_element = Proc.new.call(r, c)\n    #       self.add(new_element, r, c)\n    #     end\n    #   end\n    # end\n\n    # return a copy of this grid with grid dots\n    def griddots\n      dot = Tag.new('circle', properties: {r: 3})\n      inst = self.inst\n      inst.each_pos do |r, c|\n        inst.add(dot, r, c)\n      end\n      inst\n    end\n  end\n\n  module MyGraphics\n    attr_reader :tube, :openlid, :closedlid, :closedtube, :opentube, :detection_strip, :strip, :striplabel\n\n    # bounding box for tube elements\n    @@tubebb = SVGElement.new(boundx: 78.35, boundy: 242.95)\n\n    def rarrow\n      arrow = SVGElement.new(boundx: 33.48, boundy: 38.65)\n      arrow.new_class!(\"rarrow\")\n      arrow.add_child('\u003cpolygon points=\"0,0 33.477,19.328 0,38.655 \"/\u003e')\n    end\n\n    def larrow\n      self.rarrow.mirror_horizontal.new_class(\"larrow\")\n    end\n\n    def uparrow\n      arrow = SVGElement.new(boundx: 38.65, boundy: 33.48)\n      arrow.new_class!(\"uparrow\")\n      arrow.add_child('\u003cpolygon points=\"0,33.477 19.328,0 38.655,33.477 \"/\u003e')\n    end\n\n    def downarrow\n      self.uparrow.mirror_vertical.new_class(\"downarrow\")\n    end\n\n    def tube\n      _tube = @@tubebb.inst\n      _tube.new_class!(\"tube\")\n      _tube.add_child(\u003c\u003cEOF\n      \u003cpath fill=\"#F7FCFE\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M4.75,99.697v45.309l14.998,90.066\n        c0,4.35,5.036,7.875,11.25,7.875c6.215,0,11.25-3.525,11.25-7.875l15-90.066V99.697H4.75z\"/\u003e\n      \u003cg\u003e\n        \u003cpath fill=\"#F7FCFE\" d=\"M61.998,95.697c0,2.199-1.799,4-4,4h-54c-2.2,0-4-1.801-4-4v-1.875c0-2.201,1.8-4,4-4h54\n          c2.201,0,4,1.799,4,4V95.697z\"/\u003e\n        \u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M61.998,95.697c0,2.199-1.799,4-4,4h-54c-2.2,0-4-1.801-4-4v-1.875\n          c0-2.201,1.8-4,4-4h54c2.201,0,4,1.799,4,4V95.697z\"/\u003e\n      \u003c/g\u003e\nEOF\n      )\n      # \u003cline fill=\"#F7FCFE\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"7.721\" y1=\"123.572\" x2=\"53.387\" y2=\"123.572\"/\u003e\n      _tube.inst\n    end\n\n    def tube2mL\n      _tube = @@tubebb.inst\n      _tube.new_class!(\"tube\")\n      _tube.add_child(\u003c\u003cEOF\n        \t\u003cg id=\"2mLTube\"\u003e\n\t\t\u003cpath id=\"_x32_mLTube\" fill=\"#F7FCFE\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M57,96.698H4.503v42.581l0.479,2.704\n\t\tc-0.311,1.553-0.479,3.153-0.479,4.792v70.798c0,13.955,11.812,25.374,26.249,25.374c14.436,0,26.248-11.419,26.248-25.374v-70.798\n\t\tc0-1.639-0.17-3.239-0.48-4.792l0.48-2.704V96.698z\"/\u003e\u003c/g\u003e\nEOF\n      )\n      _tube\n    end\n\n    def closedlid\n      _closedlid = @@tubebb.inst\n      _closedlid.new_class!(\"closedlid\")\n      _closedlid.add_child(\u003c\u003cEOF\n      \u003cg\u003e\n        \u003cpath fill=\"#F7FCFE\" d=\"M55.854,80.713c22.801,0,22.801,18.312,0,18.312c0-1.189,0-2.38,0-3.57c13.912,0,13.912-11.173,0-11.173\n          C55.854,83.092,55.854,81.902,55.854,80.713z\"/\u003e\n        \u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M55.854,80.713c22.801,0,22.801,18.312,0,18.312\n          c0-1.189,0-2.38,0-3.57c13.912,0,13.912-11.173,0-11.173C55.854,83.092,55.854,81.902,55.854,80.713z\"/\u003e\n      \u003c/g\u003e\n      \u003cg\u003e\n        \u003cpath fill=\"#F7FCFE\" d=\"M10.375,101.744c0,1.1,0.9,2,2,2h37.25c1.1,0,2-0.9,2-2v-0.688c0-1.1-0.535-2-1.188-2\n          c-0.654,0-1.188-0.9-1.188-2v-8.938c0-1.1-0.9-2-2-2h-32.5c-1.1,0-2,0.9-2,2v8.938c0,1.1-0.534,2-1.188,2s-1.188,0.9-1.188,2\n          V101.744z\"/\u003e\n        \u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M10.375,101.744c0,1.1,0.9,2,2,2h37.25c1.1,0,2-0.9,2-2v-0.688\n          c0-1.1-0.535-2-1.188-2c-0.654,0-1.188-0.9-1.188-2v-8.938c0-1.1-0.9-2-2-2h-32.5c-1.1,0-2,0.9-2,2v8.938c0,1.1-0.534,2-1.188,2\n          s-1.188,0.9-1.188,2V101.744z\"/\u003e\n      \u003c/g\u003e\n      \u003cg\u003e\n        \u003cpath fill=\"#F7FCFE\" d=\"M1,81.851c-0.55-0.952-0.101-1.731,1-1.731h55.473c1.1,0,2.311,0.845,2.689,1.877l1.146,3.121\n          c0.381,1.032-0.209,1.877-1.309,1.877H5.972c-1.1,0-2.45-0.779-3-1.731L1,81.851z\"/\u003e\n        \u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M1,81.851c-0.55-0.952-0.101-1.731,1-1.731h55.473\n          c1.1,0,2.311,0.845,2.689,1.877l1.146,3.121c0.381,1.032-0.209,1.877-1.309,1.877H5.972c-1.1,0-2.45-0.779-3-1.731L1,81.851z\"/\u003e\n      \u003c/g\u003e\n      \u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"72.809\" y1=\"92.338\" x2=\"73.953\" y2=\"92.338\"/\u003e\nEOF\n      )\n      _closedlid.inst\n    end\n\n    def openlid\n      _openlid = @@tubebb.inst\n      _openlid.new_class!(\"openlid\")\n      _openlid.add_child(\u003c\u003cEOF\n      \u003cg\u003e\n        \u003cpath fill=\"#F7FCFE\" d=\"M72.42,77.695c-3.271,7.512-10.102,12.477-16.996,13.795c0.375,1.254,0.75,2.506,1.125,3.76\n          c17.402-5.207,26.029-24.734,18.164-41.105c-1.178,0.566-2.357,1.133-3.537,1.699C74.844,61.828,75.77,70.221,72.42,77.695z\"/\u003e\n        \u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M72.42,77.695c-3.271,7.512-10.102,12.477-16.996,13.795\n          c0.375,1.254,0.75,2.506,1.125,3.76c17.402-5.207,26.029-24.734,18.164-41.105c-1.178,0.566-2.357,1.133-3.537,1.699\n          C74.844,61.828,75.77,70.221,72.42,77.695z\"/\u003e\n      \u003c/g\u003e\n      \u003cg\u003e\n        \u003cpath fill=\"#F7FCFE\" d=\"M56.721,10.375c-1.1,0-2,0.9-2,2v37.25c0,1.1,0.9,2,2,2h0.688c1.1,0,2-0.534,2-1.188s0.9-1.188,2-1.188\n          h8.938c1.1,0,2-0.9,2-2v-32.5c0-1.1-0.9-2-2-2h-8.938c-1.1,0-2-0.534-2-1.188s-0.9-1.188-2-1.188H56.721z\"/\u003e\n        \u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M56.721,10.375c-1.1,0-2,0.9-2,2v37.25c0,1.1,0.9,2,2,2h0.688\n          c1.1,0,2-0.534,2-1.188s0.9-1.188,2-1.188h8.938c1.1,0,2-0.9,2-2v-32.5c0-1.1-0.9-2-2-2h-8.938c-1.1,0-2-0.534-2-1.188\n          s-0.9-1.188-2-1.188H56.721z\"/\u003e\n      \u003c/g\u003e\n      \u003cg\u003e\n        \u003cpath fill=\"#F7FCFE\" d=\"M76.613,1c0.953-0.55,1.732-0.1,1.732,1v55.471c0,1.1-0.846,2.311-1.877,2.69l-3.121,1.148\n          c-1.033,0.38-1.877-0.21-1.877-1.31V5.971c0-1.1,0.779-2.45,1.73-3L76.613,1z\"/\u003e\n        \u003cpath fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M76.613,1c0.953-0.55,1.732-0.1,1.732,1v55.471\n          c0,1.1-0.846,2.311-1.877,2.69l-3.121,1.148c-1.033,0.38-1.877-0.21-1.877-1.31V5.971c0-1.1,0.779-2.45,1.73-3L76.613,1z\"/\u003e\n      \u003c/g\u003e\n      \u003cline fill=\"#F7FCFE\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"60.408\" y1=\"47.721\" x2=\"60.408\" y2=\"14.471\"/\u003e\nEOF\n      )\n      _openlid.inst\n    end\n\n    def opentube\n      _opentube = @@tubebb.inst\n      _opentube.new_name!(\"opentube\")\n      _opentube.add_child(self.openlid)\n      _opentube.add_child(self.tube).inst\n    end\n\n    def closedtube\n      _closedtube = @@tubebb.inst\n      _closedtube.new_name!(\"closedtube\")\n      _closedtube.add_child(self.closedlid)\n      _closedtube.add_child(self.tube).inst\n    end\n\n    def strip\n      mystrip = SVGElement.new(boundx: 83.1, boundy: 247.45)\n      mystrip.add_child(\u003c\u003cEOF\n\u003cg id=\"Strip\"\u003e\n\t\u003cg\u003e\n\t\t\u003crect x=\"4.75\" fill=\"#E6E7E8\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"78.346\" height=\"242.948\"/\u003e\n\t\t\u003cline fill=\"#E6E7E8\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"0\" y1=\"247.448\" x2=\"4.75\" y2=\"242.948\"/\u003e\n\t\t\u003cpolygon fill=\"#E6E7E8\" stroke=\"#000000\" stroke-miterlimit=\"10\" points=\"-0.067,4.777 4.75,0.001 4.75,242.948 0,247.448 \t\t\"/\u003e\n\t\t\u003cpolygon fill=\"#E6E7E8\" stroke=\"#000000\" stroke-miterlimit=\"10\" points=\"74.917,247.448 0,247.448 4.75,242.948 83.096,242.948 \n\t\t\t\t\t\"/\u003e\n\t\u003c/g\u003e\n\t\u003cg\u003e\n\t\t\u003crect x=\"19.583\" y=\"49.433\" fill=\"#E6E7E8\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"46.667\" height=\"80\"/\u003e\n\t\t\u003crect x=\"27.083\" y=\"57.433\" fill=\"#FFFFFF\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"31.667\" height=\"64\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"27.083\" y1=\"121.433\" x2=\"19.583\" y2=\"129.433\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"58.75\" y1=\"121.433\" x2=\"66.25\" y2=\"129.433\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"58.75\" y1=\"57.433\" x2=\"66.25\" y2=\"49.433\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"27.083\" y1=\"57.433\" x2=\"19.583\" y2=\"49.433\"/\u003e\n\t\u003c/g\u003e\n\t\u003cg\u003e\n\t\t\u003cpath fill=\"#E6E7E8\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M57.524,216.515c0,4.385-3.693,7.938-8.249,7.938H36.557\n\t\t\tc-4.556,0-8.249-3.554-8.249-7.938v-22.164c0-4.385,3.693-7.939,8.249-7.939h12.718c4.556,0,8.249,3.554,8.249,7.939V216.515z\"/\u003e\n\t\t\u003cpath fill=\"#FFFFFF\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M52.917,213.019c0,3.002-2.528,5.435-5.647,5.435h-8.706\n\t\t\tc-3.119,0-5.647-2.433-5.647-5.435v-15.172c0-3.001,2.528-5.435,5.647-5.435h8.706c3.119,0,5.647,2.433,5.647,5.435V213.019z\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"34.01\" y1=\"216.224\" x2=\"30.27\" y2=\"221.647\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"51.823\" y1=\"216.224\" x2=\"55.562\" y2=\"221.647\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"51.823\" y1=\"194.642\" x2=\"55.023\" y2=\"188.663\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"34.01\" y1=\"194.195\" x2=\"30.27\" y2=\"189.666\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"32.917\" y1=\"205.433\" x2=\"28.308\" y2=\"205.433\"/\u003e\n\t\t\u003cline fill=\"none\" stroke=\"#000000\" stroke-miterlimit=\"10\" x1=\"52.917\" y1=\"205.433\" x2=\"57.524\" y2=\"205.433\"/\u003e\n\t\u003c/g\u003e\n\n\u003c/g\u003e\nEOF\n      )\n    end\n\n    def fluid_small\n      fluid = @@tubebb.inst\n      fluid.new_class!(\"fluid\")\n      fluid.new_name!(\"small_fluid\")\n      fluid.add_child(\u003c\u003cEOF\n      \u003cpath id=\"FluidSmall\" fill=\"#00AEEF\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M44.565,216.853\n\tc-12.031,0-12.031,8.833-24.062,8.833c-0.825,0-1.589-0.045-2.309-0.122l1.584,9.509c0,4.35,5.036,7.875,11.249,7.875\n\tc6.215,0,11.25-3.525,11.25-7.875l3.031-18.202C45.063,216.862,44.821,216.853,44.565,216.853z\"/\u003e\nEOF\n      )\n    end\n\n    def fluid_medium\n      fluid = @@tubebb.inst\n      fluid.new_class!(\"fluid\")\n      fluid.new_name!(\"med_fluid\")\n      fluid.add_child(\u003c\u003cEOF\n\u003cpath id=\"FluidMedium\" fill=\"#00AEEF\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M44.315,166.187\n\tc-12.031,0-12.031,8.833-24.062,8.833c-5.585,0-8.576-1.904-11.383-3.944l10.657,63.997c0,4.35,5.036,7.875,11.249,7.875\n\tc6.215,0,11.25-3.525,11.25-7.875l11.101-66.649C50.918,167.142,48.268,166.187,44.315,166.187z\"/\u003e\nEOF\n      )\n    end\n\n    def fluid_large\n      fluid = @@tubebb.inst\n      fluid.new_class!(\"fluid\")\n      fluid.new_name!(\"small_fluid\")\n      fluid.add_child(\u003c\u003cEOF\n\u003cpath id=\"FluidLarge\" fill=\"#BCE6FB\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M43.202,110.52\n\tc-12.031,0-12.031,8.833-24.062,8.833c-7.554,0-10.365-3.483-14.39-6.075v31.729l14.998,90.066c0,4.35,5.036,7.875,11.249,7.875\n\tc6.215,0,11.25-3.525,11.25-7.875l15-90.066v-28.64C53.402,113.803,50.538,110.52,43.202,110.52z\"/\u003e\nEOF\n      )\n    end\n\n    def powder\n      powder = @@tubebb.inst\n      powder.new_class!(\"powder\")\n      powder.new_name!(\"powder\")\n      powder.add_child(\u003c\u003cEOF\n         \u003cpath id=\"Powder\" fill=\"#FFFFFF\" stroke=\"#000000\" stroke-miterlimit=\"10\" d=\"M27.784,234.289c-0.647-2.643,1.036-2.308,2.842-2.495\n\tc1.183-0.124,3.538-0.179,4.792,0.55c0.33,0.957,1.645,1.147,1.775,1.945c0.106,0.649-1.18,1.446-1.407,1.983\n\tc-0.399,0.946,0.521,1.041-0.603,2.289c-0.534,0.593-2.338,1.107-3.088,1.463c-0.073,0.265-0.021,0.495-0.09,0.763\n\tc-1.498,0.401-7.79-0.416-4.875-2.518c-1.888-1.042-0.182-4.734,1.506-4.551\"/\u003e\nEOF\n      )\n    end\n\n    def striplabel\n      mylabel = SVGElement.new(boundx: 83.1, boundy: 247.45)\n      mylabel.add_child(\u003c\u003cEOF\n\u003cg id=\"StripLabel\" class=\"fluid\"\u003e\n\t\u003crect x=\"4.75\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"78.346\" height=\"46.433\"/\u003e\n\u003c/g\u003e\nEOF\n      )\n    end\n\n    def detection_strip\n      mystrip = SVGElement.new(boundx: 83.1, boundy: 247.45)\n      mystrip.add_child(self.strip)\n      mystrip.add_child(self.striplabel)\n    end\n\n    def control_band\n      band = SVGElement.new(boundx: 83.1, boundy: 247.45)\n      band.add_child(\u003c\u003cEOF\n\u003cline id=\"ControlBand\" fill=\"none\" stroke=\"#F7A7AB\" stroke-width=\"6\" stroke-miterlimit=\"10\" x1=\"27.083\" y1=\"68.432\" x2=\"58.75\" y2=\"68.432\"/\u003e\nEOF\n      )\n    end\n\n    def wt_band\n      band = SVGElement.new(boundx: 83.1, boundy: 247.45)\n      band.add_child(\u003c\u003cEOF\n\u003cline id=\"WTBand\" fill=\"none\" stroke=\"#F7A7AB\" stroke-width=\"6\" stroke-miterlimit=\"10\" x1=\"27.089\" y1=\"89.433\" x2=\"58.756\" y2=\"89.433\"/\u003e\nEOF\n      )\n    end\n\n    def mut_band\n      band = SVGElement.new(boundx: 83.1, boundy: 247.45)\n      band.add_child(\u003c\u003cEOF\n\u003cline id=\"MutantBand\" fill=\"none\" stroke=\"#F7A7AB\" stroke-width=\"6\" stroke-miterlimit=\"10\" x1=\"27.089\" y1=\"111.099\" x2=\"58.756\" y2=\"111.099\"/\u003e\nEOF\n      )\n    end\n  end\n\n  ########################################################################\n  # ####\n  # ####\n  # #### GRAPHICS TESTING\n  # ####\n  # ####\n  ########################################################################\n\n\n  def save_svg(filename, svg)\n    File.write(filename, svg.to_str)\n  end\nend\n\n\n"}}]}